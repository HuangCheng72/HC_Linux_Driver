# 七：最基本的DMA驱动



## 0. 框架部分问题探讨

### 0.1 可改可不改的

我在virt-dma.h里面看到了这个

```c
static inline void vchan_free_chan_resources(struct virt_dma_chan *vc)
{
	struct virt_dma_desc *vd;
	unsigned long flags;
	LIST_HEAD(head);

	spin_lock_irqsave(&vc->lock, flags);
	vchan_get_all_descriptors(vc, &head);
	list_for_each_entry(vd, &head, node)
		dmaengine_desc_clear_reuse(&vd->tx);
	spin_unlock_irqrestore(&vc->lock, flags);

	vchan_dma_desc_free_list(vc, &head);
}

```

修改 `hc_dma_probe` 和 `hc_dma_remove` 中的这句：

```c
// 替换的是下面这句
// list_del(&vchan->vc.chan.device_node);
vchan_free_chan_resources(&vchan->vc);

```

这样的好处是更保险，不过在probe的时候，不可能有描述符，所以检查释放描述符有点画蛇添足了，而remove之前，照理来说，怎么可能还剩下描述符？如果没完成的话应该是不准卸载才对，哪怕是你传输不成功，也得返回一个fail吧，怎么能直接卸载驱动交出资源？这是个逻辑问题，不是个编程问题。

### 0.2 必须澄清的

virt-dma.h中的结构体定义如下：

```c
struct virt_dma_desc {
	struct dma_async_tx_descriptor tx;
	/* protected by vc.lock */
	struct list_head node;
};

struct virt_dma_chan {
	struct dma_chan	chan;
	struct tasklet_struct task;
	void (*desc_free)(struct virt_dma_desc *);

	spinlock_t lock;

	/* protected by vc.lock */
	struct list_head desc_allocated;
	struct list_head desc_submitted;
	struct list_head desc_issued;
	struct list_head desc_completed;

	struct virt_dma_desc *cyclic;
};

```

可以看到，virt_dma_chan的第一个成员是`struct dma_chan`类型的，所以可以直接强转类型访问virt_dma_chan，也就是

```c
struct dma_chan *ptr_chan;    // 这是一个dma_chan结构体的指针
struct virt_dma_chan *ptr_vchan = (struct virt_dma_chan *)ptr_chan; // 这是它所在的virt_dma_chan结构体的指针
```

而DMA驱动框架里结构体是

```c
// 前向声明虚拟通道结构体，后面再定义
typedef struct hc_sun6i_dma_virtual_channel_info DMA_Virtual_Channel_Info;

// 该结构体记录一个DMA虚拟通道的所有信息
struct hc_sun6i_dma_virtual_channel_info {
    struct virt_dma_chan    vc;         // Linux内核DMA驱动框架提供的虚拟DMA通道结构体
    DMA_Physical_Channel_Info * pchan;  // 当前绑定的物理通道（如果当前无任务应为NULL）

    struct dma_slave_config cfg;        // 该虚拟通道的从设备配置
    uint32_t                port;       // 该虚拟通道对应的DRQ端口
    uint32_t                irq_type;   // 中断类型
    bool                    cyclic;     // 该虚拟通道是否为循环DMA模式

    struct list_head        task_queue_head;    // 该虚拟通道的任务队列
    DMA_TASK_Descriptor *   task;               // 该虚拟通道当前正在处理的任务
};
```

同理有

```c
DMA_Virtual_Channel_Info *ptr_v_dma_chan = (DMA_Virtual_Channel_Info *)ptr_chan; // 这是它所在的DMA_Virtual_Channel_Info结构体的指针
```

所以 `hc_dma_of_xlate` 函数中的

```c
// 虚拟通道对应到该设备的端口，并写入结构体成员中
((DMA_Virtual_Channel_Info *)chan)->port = port;

```

这个做法在这样的前提条件下没有任何问题，甚至可以说是最快捷的做法。



### 0.3 真正有误的

寄存器定义有误，GPT识图出了问题，居然没检查，真的不能完全信AI，检查是必须的。

```c
// DMA 通道专用寄存器 (N=0到11)
#define DMA_EN_REG_OFFSET(N)        (0x100 + 0x40 * (N) + 0x00)     // DMA 通道使能寄存器 (N=0到11)
#define DMA_PAU_REG_OFFSET(N)       (0x100 + 0x40 * (N) + 0x04)     // DMA 通道暂停寄存器 (N=0到11)
#define DMA_DESC_ADDR_REG_OFFSET(N) (0x100 + 0x40 * (N) + 0x08)     // DMA 通道开始地址寄存器 (N=0到11)
#define DMA_CFG_REG_OFFSET(N)       (0x100 + 0x40 * (N) + 0x0C)     // DMA 通道配置寄存器 (N=0到11)
#define DMA_CUR_SRC_REG_OFFSET(N)   (0x100 + 0x40 * (N) + 0x10)     // DMA 通道当前源地址寄存器 (N=0到11)
#define DMA_CUR_DEST_REG_OFFSET(N)  (0x100 + 0x40 * (N) + 0x14)     // DMA 通道当前目标地址寄存器 (N=0到11)
#define DMA_BCNT_LEFT_REG_OFFSET(N) (0x100 + 0x40 * (N) + 0x18)     // DMA 通道剩余字节计数器寄存器 (N=0到11)
#define DMA_PARA_REG_OFFSET(N)      (0x100 + 0x40 * (N) + 0x1C)     // DMA 通道参数寄存器 (N=0到11)
#define DMA_FDESC_ADDR_REG_OFFSET(N)(0x100 + 0x40 * (N) + 0x2C)     // DMA 前描述符地址寄存器 (N=0到11)
#define DMA_PKG_NUM_REG_OFFSET(N)   (0x100 + 0x40 * (N) + 0x30)     // DMA 数据包编号寄存器 (N=0到11)

```

结构体定义，`DMA_TASK_Descriptor` 处，第二个参数physical_addr的类型错了，不是指针类型，改正如下。

```c
// 驱动使用的DMA任务描述符，实际上就是简单包装一下DMA_HardWare_Descriptor，获取相关信息的时候方便一些，并继承Linux内核DMA驱动框架的虚拟通道描述符
typedef struct hc_dma_task_descriptor {
    struct virt_dma_desc    vd;             // Linux内核的虚拟DMA框架的DMA任务描述符，继承这个，就可以让Linux内核自动管理这个描述符
    dma_addr_t physical_addr;               // 描述符的物理地址
    DMA_HardWare_Descriptor * virtual_addr; // 描述符的虚拟地址
} DMA_TASK_Descriptor;

```

结构体定义 `struct hc_sun6i_dma_virtual_channel_info` 处，最后两个参数我之前设想有误，我设想的功能没用上，只能改了，否则容易造成误导。

```c
// 该结构体记录一个DMA虚拟通道的所有信息
struct hc_sun6i_dma_virtual_channel_info {
    struct virt_dma_chan    vc;         // Linux内核DMA驱动框架提供的虚拟DMA通道结构体
    DMA_Physical_Channel_Info * pchan;  // 当前绑定的物理通道（如果当前无任务应为NULL）

    struct dma_slave_config cfg;        // 该虚拟通道的从设备配置
    uint32_t                port;       // 该虚拟通道对应的DRQ端口
    uint32_t                irq_type;   // 中断类型
    bool                    cyclic;     // 该虚拟通道是否为循环DMA模式

    struct list_head        pending_node;    // 该虚拟通道的任务等待结点，用于挂到DMA_DEV_Info的pending上
    bool                    need_start;      // 该虚拟通道是否需要启动传输的标志
};

```

相应地，`hc_probe` 里面修改这部分

```c
    // 初始化虚拟通道数组
    for (i = 0; i < dma_dev->cfg->max_virtual_channels; i++) {
        INIT_LIST_HEAD(&vchan->pending_node);    // 修改这里，其他不变
    }
```

两个函数的声明和定义需要修改

```c
static int hc_dma_start_transfer(DMA_DEV_Info *dma_dev, DMA_Virtual_Channel_Info *vchan);
static void hc_dma_stop_transfer(DMA_DEV_Info *dma_dev, DMA_Virtual_Channel_Info *vchan);

/*
 * DMA传输启动函数
 * 功能: 启动DMA传输操作。
 */
static int hc_dma_start_transfer(DMA_DEV_Info *dma_dev, DMA_Virtual_Channel_Info *vchan) {
    return 0;  // 成功启动
}

/*
 * DMA传输停止函数
 * 功能: 停止DMA传输操作。
 */
static void hc_dma_stop_transfer(DMA_DEV_Info *dma_dev, DMA_Virtual_Channel_Info *vchan) {
    // 暂时不处理
}

```



## 1. DMA驱动测试模块

这个模块用于测试DMA驱动的能力，目前只测试内存到内存的。

dma_test.c

```c
//
// Created by huangcheng on 2024/9/6.
//

#include <linux/module.h>
#include <linux/dmaengine.h>
#include <linux/dma-mapping.h>
#include <linux/init.h>
#include <linux/interrupt.h>
#include <linux/slab.h>
#include <linux/platform_device.h>
#include <linux/wait.h>
#include <linux/completion.h>

#define DMA_BUFFER_SIZE 1024

static dma_addr_t dma_src, dma_dst;
static char *src_buf, *dst_buf;
static struct dma_chan *dma_chan;
static struct completion dma_complete;

static void dma_callback(void *completion)
{
    complete(completion);
    pr_info("DMA transfer completed\n");
}

static int dma_test(void)
{
    struct dma_device *dma_dev;
    struct dma_async_tx_descriptor *tx;
    dma_cap_mask_t mask;
    enum dma_ctrl_flags flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;
    int ret;

    pr_info("DMA test started\n");

    // Step 1: 设置DMA引擎能力掩码，表示支持内存到内存的DMA传输
    dma_cap_zero(mask);
    dma_cap_set(DMA_MEMCPY, mask);

    // Step 2: 请求DMA通道
    dma_chan = dma_request_chan_by_mask(&mask);
    if (IS_ERR(dma_chan)) {
        pr_err("Failed to request DMA channel\n");
        return PTR_ERR(dma_chan);
    }

    dma_dev = dma_chan->device;

    // Step 3: 分配源和目标缓冲区
    src_buf = kzalloc(DMA_BUFFER_SIZE, GFP_KERNEL);
    dst_buf = kzalloc(DMA_BUFFER_SIZE, GFP_KERNEL);
    if (!src_buf || !dst_buf) {
        pr_err("Failed to allocate buffers\n");
        ret = -ENOMEM;
        goto err_free_buf;
    }

    // Step 4: 将源和目标缓冲区映射到DMA地址空间
    dma_src = dma_map_single(dma_dev->dev, src_buf, DMA_BUFFER_SIZE, DMA_TO_DEVICE);
    dma_dst = dma_map_single(dma_dev->dev, dst_buf, DMA_BUFFER_SIZE, DMA_FROM_DEVICE);

    if (dma_mapping_error(dma_dev->dev, dma_src) || dma_mapping_error(dma_dev->dev, dma_dst)) {
        pr_err("DMA mapping error\n");
        ret = -EIO;
        goto err_unmap;
    }

    // Step 5: 准备DMA传输
    tx = dma_dev->device_prep_dma_memcpy(dma_chan, dma_dst, dma_src, DMA_BUFFER_SIZE, flags);
    if (!tx) {
        pr_err("Failed to prepare DMA memcpy\n");
        ret = -EIO;
        goto err_unmap;
    }

    // Step 6: 设置DMA传输完成的回调函数
    init_completion(&dma_complete);
    tx->callback = dma_callback;
    tx->callback_param = &dma_complete;

    // Step 7: 提交并启动DMA传输
    dmaengine_submit(tx);
    dma_async_issue_pending(dma_chan);

    // Step 8: 等待DMA传输完成
    wait_for_completion(&dma_complete);

    pr_info("DMA test finished successfully\n");
    ret = 0;

err_unmap:
    dma_unmap_single(dma_dev->dev, dma_src, DMA_BUFFER_SIZE, DMA_TO_DEVICE);
    dma_unmap_single(dma_dev->dev, dma_dst, DMA_BUFFER_SIZE, DMA_FROM_DEVICE);

err_free_buf:
    kfree(src_buf);
    kfree(dst_buf);
    dma_release_channel(dma_chan);

    return ret;
}

static int __init dma_test_init(void)
{
    pr_info("Initializing DMA test module\n");
    return dma_test();
}

static void __exit dma_test_exit(void)
{
    pr_info("Exiting DMA test module\n");
}

module_init(dma_test_init);
module_exit(dma_test_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("huangcheng");
MODULE_DESCRIPTION("Basic DMA test module");

```

这是测试之前带DMA驱动的老内核的结果。区别很简单，老内核的内置DMA驱动有34个DMA通道，本项目的DMA驱动只有30个通道（故意这么做的，以示区别）。

```bash
/ # ls /sys/class/dma
dma0chan0   dma0chan14  dma0chan2   dma0chan25  dma0chan30  dma0chan6
dma0chan1   dma0chan15  dma0chan20  dma0chan26  dma0chan31  dma0chan7
dma0chan10  dma0chan16  dma0chan21  dma0chan27  dma0chan32  dma0chan8
dma0chan11  dma0chan17  dma0chan22  dma0chan28  dma0chan33  dma0chan9
dma0chan12  dma0chan18  dma0chan23  dma0chan29  dma0chan4
dma0chan13  dma0chan19  dma0chan24  dma0chan3   dma0chan5
/ # cd home
/home # insmod dma_test.ko
[   11.930646] dma_test: loading out-of-tree module taints kernel.
[   11.937036] Initializing DMA test module
[   11.941050] DMA test started
[   11.944075] DMA transfer completed
[   11.947502] DMA test finished successfully

```

老内核成功过关。



## 2. DMA驱动实现

### 2.1  实现思路

分析上面DMA测试模块，涉及到操作如下：

1. 设置传输能力要求（通过设置掩码实现，属于Linux的DMA引擎框架管理）。
2. 请求具备该传输能力的一条DMA通道（这里就要求实现框架里的 `hc_dma_alloc_chan_resources` ，既然有alloc，那么 `hc_dma_ree_chan_resources` 也必须相应实现）。
3. 分配DMA缓冲区（和DMA驱动没关系）。
4. 将缓冲区映射到DMA空间（这是Linux内核中的DMA映射框架提供的功能，DMA空间也是Linux内核实际管理，和硬件驱动无关）。
5. DMA传输准备（看名字就知道，要实现 `hc_dma_prep_dma_memcpy` ）。
6. 状态检测，如果完成传输，就调用相应的回调函数（实现 `hc_dma_tx_status` ）。
7. 提交DMA传输任务，启动传输（提交到DMA引擎，加入到等待队列，DMA引擎这个不用管，看名字也知道硬件驱动要实现 `hc_dma_issue_pending` ）。
8. 等待DMA传输完成（和6一样，要实现 `hc_dma_tx_status` ）。

考虑到几个问题：

1. 分配通道之后，应当对通道进行一定的配置，因此实现 `hc_dma_config` 是必须的。
2. 需要启动实际的传输，所以应当实现 `hc_dma_start_transfer` ，因此对应的 `hc_dma_stop_transfer` 也应当考虑实现（即使在测试中用不到）。
3. 传输完成后，DMA驱动要打完成中断，才能知道完成传输了，因此实现DMA中断处理函数 `hc_dma_interrupt` 和 中断处理下半部分的 `hc_dma_tasklet` 是必须的。

所以要实现的函数为：

```c
static int hc_dma_alloc_chan_resources(struct dma_chan *chan);
static void hc_dma_free_chan_resources(struct dma_chan *chan);
static int hc_dma_config(struct dma_chan *chan, struct dma_slave_config *config);
static struct dma_async_tx_descriptor *hc_dma_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest, dma_addr_t src, size_t len, unsigned long flags);
static enum dma_status hc_dma_tx_status(struct dma_chan *chan, dma_cookie_t cookie, struct dma_tx_state *state);
static void hc_dma_issue_pending(struct dma_chan *chan);
static int hc_dma_start_transfer(DMA_DEV_Info *dma_dev, DMA_Virtual_Channel_Info *vchan);
static void hc_dma_stop_transfer(DMA_DEV_Info *dma_dev, DMA_Virtual_Channel_Info *vchan);
static irqreturn_t hc_dma_interrupt(int irq, void *dev_id);
static void hc_dma_tasklet(unsigned long data);

```

虽然是一个最基本的实现内存到内存传输功能的DMA驱动，但是要做这么多，真的很麻烦。



### 2.2 实现驱动的准备工作

### 2.2.1 spinlock_t 自旋锁

在 Linux 内核中，`spinlock_t` 类型的自旋锁是一种用于保护共享资源的同步机制。在多核系统中，使用自旋锁可以防止多个处理器同时访问同一资源。与互斥锁不同的是，自旋锁在等待时不会引起调度，而是会一直自旋直到获得锁。这使得自旋锁适合用于保护那些访问时间非常短的临界区。

以下是与 `spinlock_t` 类型自旋锁相关的常用加锁和解锁函数，按其用途进行分类：

```c
void spin_lock(spinlock_t *lock);
```
**作用**：获取一个自旋锁。如果锁已被其他处理器或线程持有，它会一直自旋，直到获得该锁。

```c
void spin_unlock(spinlock_t *lock);
```
**作用**：释放一个自旋锁，允许其他等待的处理器或线程获得该锁。

```c
void spin_lock_irq(spinlock_t *lock);
```
**作用**：在获取自旋锁之前禁用本地 CPU 的中断，防止在持有锁期间发生中断。

```c
void spin_unlock_irq(spinlock_t *lock);
```
**作用**：释放自旋锁并重新启用本地 CPU 的中断。

```c
void spin_lock_irqsave(spinlock_t *lock, unsigned long flags);
```
**作用**：禁用本地 CPU 的中断并保存当前中断状态到 `flags` 变量。适合在需要嵌套使用自旋锁的场景中，保存中断状态以便后续恢复。

```c
void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags);
```
**作用**：释放自旋锁并恢复之前保存的中断状态（通过 `flags` 恢复）。

```c
void spin_lock_bh(spinlock_t *lock);
```
**作用**：禁止本地 CPU 处理软中断并获取自旋锁，适合软中断上下文的临界区保护。

```c
void spin_unlock_bh(spinlock_t *lock);
```
**作用**：释放自旋锁并允许处理软中断。

```c
int spin_trylock(spinlock_t *lock);
```
**作用**：尝试获取自旋锁。如果锁已经被持有，立即返回 0；如果成功获取锁，则返回 1。不会自旋等待。

```c
int spin_trylock_irqsave(spinlock_t *lock, unsigned long *flags);
```
**作用**：类似于 `spin_trylock()`，但在尝试获取锁时禁用中断，并保存中断状态到 `flags`。如果获取失败，也会立即返回而不会等待。





### 2.3 实现过程

#### 2.3.1 hc_dma_alloc_chan_resources

virt-dma.h中，已经把虚拟通道的资源分配了。

```c
void vchan_init(struct virt_dma_chan *vc, struct dma_device *dmadev)
{
	dma_cookie_init(&vc->chan);

	spin_lock_init(&vc->lock);
	INIT_LIST_HEAD(&vc->desc_allocated);
	INIT_LIST_HEAD(&vc->desc_submitted);
	INIT_LIST_HEAD(&vc->desc_issued);
	INIT_LIST_HEAD(&vc->desc_completed);

	tasklet_init(&vc->task, vchan_complete, (unsigned long)vc);

	vc->chan.device = dmadev;
	list_add_tail(&vc->chan.device_node, &dmadev->channels);
}
EXPORT_SYMBOL_GPL(vchan_init);
```

在probe里面又分配（初始化）了这个DMA驱动的虚拟通道的剩下资源。

```c
    // 给虚拟通道数组分配内存
    dma_dev->vchans = devm_kcalloc(&pdev->dev, dma_dev->cfg->max_virtual_channels, sizeof(DMA_Virtual_Channel_Info), GFP_KERNEL);
    if (!dma_dev->vchans) {
        return -ENOMEM;
    }

    // 初始化虚拟通道数组
    for (i = 0; i < dma_dev->cfg->max_virtual_channels; i++) {
        DMA_Virtual_Channel_Info *vchan = &dma_dev->vchans[i];

        // 同理，现在是初始化阶段，没有任何任务，做一点简单的初始化就行了
        vchan->pchan = NULL;

        vchan->port = 0;
        vchan->irq_type = 0;
        vchan->cyclic = false;
        INIT_LIST_HEAD(&vchan->pending_node);
        vchan->need_start = false;

        // 关联描述符的free函数指针，这样内核就可以自动释放DMA描述符了，这里关联任务描述符释放函数，因为任务描述符才是DMA驱动使用，而不是硬件使用的
        vchan->vc.desc_free = hc_free_dma_task_descriptor;

        // 初始化这个虚拟通道
        vchan_init(&vchan->vc, &dma_dev->slave);
    }

```

物理通道，其实我们已经在probe里面分配好了。这有点失算了。

```c
    // 给物理通道数组分配内存
    dma_dev->pchans = devm_kcalloc(&pdev->dev, dma_dev->cfg->max_physical_channels, sizeof(DMA_Physical_Channel_Info), GFP_KERNEL);
    if (!dma_dev->pchans) {
        return -ENOMEM;
    }

    // 初始化物理通道数组
    for (i = 0; i < dma_dev->cfg->max_physical_channels; i++) {
        DMA_Physical_Channel_Info *pchan = &dma_dev->pchans[i];
        pchan->index = i;
        pchan->base_addr = dma_dev->base_addr + DMA_EN_REG_OFFSET(i);

        // 现在是初始化阶段，肯定没任务，置为NULL就对了
        pchan->todo = NULL;
        pchan->done = NULL;
        pchan->vchan = NULL;
    }

```

所以 `hc_dma_alloc_chan_resources` 没事可干，直接这么保持原样：

```c
/*
 * DMA通道分配函数
 * 功能: 为每个虚拟或物理DMA通道分配资源。
 */
static int hc_dma_alloc_chan_resources(struct dma_chan *chan) {
    return 0;  // 成功分配资源
}

```

如果需要修改，让`hc_dma_alloc_chan_resources` 有事可做的话，这个函数分配的是 **单独一条虚拟通道** 的资源，这一点需要注意。



#### 2.3.2 hc_dma_free_chan_resources

这里其实就是清理一下这个虚拟通道的资源。因为之前也说了virt-dma.h里面也有一个 `vchan_free_chan_resources` 函数，这东西能彻底清理Linux内核提供的虚拟通道机制的所有资源，但是这清理不了这个驱动的DMA虚拟通道结构体带着的资源，所以需要单独清理。

这个驱动的DMA虚拟通道结构体如下：

```c
// 该结构体记录一个DMA虚拟通道的所有信息
struct hc_sun6i_dma_virtual_channel_info {
    struct virt_dma_chan    vc;         // Linux内核DMA驱动框架提供的虚拟DMA通道结构体
    DMA_Physical_Channel_Info * pchan;  // 当前绑定的物理通道（如果当前无任务应为NULL）

    struct dma_slave_config cfg;        // 该虚拟通道的从设备配置
    uint32_t                port;       // 该虚拟通道对应的DRQ端口
    uint32_t                irq_type;   // 中断类型
    bool                    cyclic;     // 该虚拟通道是否为循环DMA模式

    struct list_head        pending_node;    // 该虚拟通道的任务等待结点，用于挂到DMA_DEV_Info的pending上
    bool                    need_start;      // 该虚拟通道是否需要启动传输的标志
};

```

资源就是这些。不过除了 `pending_node` ，其他的都 **不干涉** 到其他DMA虚拟通道。因为无关，完全可以等着后面直接把内存回收了，都不用清理了。

pending_node是链接在大链表也就是DMA_DEV_Info的pending上的，所以必须要用链表操作API将其删除，不删除的话，就会导致出现不该出现的结点，就影响到其他的虚拟通道了。

```c
/*
 * 释放通道资源函数
 * 功能: 释放与DMA通道相关的资源。
 */
static void hc_dma_free_chan_resources(struct dma_chan *chan) {
    // 获取所需的两个指针，设备信息结构体和虚拟通道结构体

    DMA_DEV_Info *dma_dev = (DMA_DEV_Info *)(chan->device);
    DMA_Virtual_Channel_Info *vchan = (DMA_Virtual_Channel_Info *)chan;

    // 这是保存上下文的变量
    unsigned long flags;

    // 用设备信息结构体的锁（锁的是整个设备）来保护操作，因为可能进入中断状态，所以要保存中断状态上下文
    spin_lock_irqsave(&dma_dev->lock, flags);
    list_del_init(&vchan->pending_node);         //进行的操作就是把任务队列结点从大链表中删掉，具体来说就是DMA_DEV_Info的pending
    spin_unlock_irqrestore(&dma_dev->lock, flags);

    // 释放虚拟通道的全部资源
    vchan_free_chan_resources(&vchan->vc);
}

```

如果想清理其他的，直接在最后来个memset完事。



#### 2.3.3 hc_dma_config

先看要配置的是什么，依然是虚拟通道结构体：

```c
// 该结构体记录一个DMA虚拟通道的所有信息
struct hc_sun6i_dma_virtual_channel_info {
    struct virt_dma_chan    vc;         // Linux内核DMA驱动框架提供的虚拟DMA通道结构体
    DMA_Physical_Channel_Info * pchan;  // 当前绑定的物理通道（如果当前无任务应为NULL）

    struct dma_slave_config cfg;        // 该虚拟通道的从设备配置
    uint32_t                port;       // 该虚拟通道对应的DRQ端口
    uint32_t                irq_type;   // 中断类型
    bool                    cyclic;     // 该虚拟通道是否为循环DMA模式

    struct list_head        pending_node;    // 该虚拟通道的任务等待结点，用于挂到DMA_DEV_Info的pending上
    bool                    need_start;      // 该虚拟通道是否需要启动传输的标志
};

```

这么一看直接复制过去就完事了。这个不用解释了，太简单了。

```c
/*
 * DMA通道配置函数
 * 功能: 配置DMA通道的相关设置（地址宽度、突发长度等）。
 */
static int hc_dma_config(struct dma_chan *chan, struct dma_slave_config *config) {
    DMA_Virtual_Channel_Info *vchan = (DMA_Virtual_Channel_Info *)chan;
    memcpy(&vchan->cfg, config, sizeof(*config));
    return 0;  // 返回成功
}

```



#### 2.3.4 hc_dma_prep_dma_memcpy

这个函数是为不同种类的DMA操作准备操作符，操作符是什么，自然就是这两个。

```c
// 硬件DMA控制器所需的描述符结构体定义，该结构体实例的地址写入到 DMA_DESC_ADDR_REG_OFFSET(N) 中
typedef struct hc_sun6i_dma_descriptor {
    DMA_CFG_REG_t cfg;                  // DMA配置项
    DMA_CUR_SRC_REG_t src;              // 源地址
    DMA_CUR_DEST_REG_t dst;             // 目的地址
    uint32_t len;                       // 数据长度
    DMA_PARA_REG_t para;                // 传输的附加参数
    dma_addr_t  p_next_dma_descriptor;  // 下一个描述符的物理地址（如果没有下一个，就要置为DMA_DESCRIPTOR_END_ADDRESS，即0xFFFFF800）

    // 解释说明
    // dma_addr_t 是在 Linux 内核中用来表示 DMA（直接内存访问）操作时物理地址的类型（32位机器是uint32_t，64位机器是uint64_t）。

    // DMA控制器读到第六个参数，也就是p_next_dma_descriptor就会直接跳转到下一个描述符
    // v_next_dma_descriptor是用来给软件控制逻辑判断用的
    // DMA控制器是硬件，不受CPU的MMU影响，所以只能是物理地址
    // 但是如果是在CPU上运行，受MMU控制，不能直接访问物理地址，还是需要虚拟地址的

    struct hc_sun6i_dma_descriptor *v_next_dma_descriptor;  // 指向下一个描述符的虚拟地址

} DMA_HardWare_Descriptor;

// 驱动使用的DMA任务描述符，实际上就是简单包装一下DMA_HardWare_Descriptor，获取相关信息的时候方便一些，并继承Linux内核DMA驱动框架的虚拟通道描述符
typedef struct hc_dma_task_descriptor {
    struct virt_dma_desc    vd;             // Linux内核的虚拟DMA框架的DMA任务描述符，继承这个，就可以让Linux内核自动管理这个描述符
    dma_addr_t physical_addr;               // 描述符的物理地址
    DMA_HardWare_Descriptor * virtual_addr; // 描述符的虚拟地址
} DMA_TASK_Descriptor;

```

DMA_HardWare_Descriptor中设计的各种结构体类型。

```c
// DMA_CFG_REG 位域结构体定义，来自技术手册p203 4.11.4.11 DMA Channel Configuration Register
typedef struct {
    uint32_t DMA_SRC_DRQ_TYPE   : 5;  // [0:4] DMA 源端 DRQ 类型，只读
    uint32_t DMA_SRC_ADDR_MODE  : 1;  // [5] DMA 源端地址模式，0: 线性模式, 1: IO模式，只读
    uint32_t DMA_SRC_BST_LEN    : 2;  // [6:7] DMA 源端突发长度，00: 1, 01: 4, 10: 8, 11: 16，只读
    uint32_t RESERVED8          : 1;  // [8] 保留位
    uint32_t DMA_SRC_DATA_WIDTH : 2;  // [9:10] DMA 源端数据宽度，00: 8位, 01: 16位, 10: 32位, 11: 64位，只读
    uint32_t RESERVED11_15      : 5;  // [11:15] 保留位
    uint32_t DMA_DEST_DRQ_TYPE  : 5;  // [16:20] DMA 目的端 DRQ 类型，只读
    uint32_t DMA_DEST_ADDR_MODE : 1;  // [21] DMA 目的端地址模式，0: 线性模式, 1: IO模式，只读
    uint32_t DMA_DEST_BST_LEN   : 2;  // [22:23] DMA 目的端突发长度，00: 1, 01: 4, 10: 8, 11: 16，只读
    uint32_t RESERVED24         : 1;  // [24] 保留位
    uint32_t DMA_DEST_DATA_WIDTH: 2;  // [25:26] DMA 目的端数据宽度，00: 8位, 01: 16位, 10: 32位, 11: 64位，只读
    uint32_t RESERVED27_31      : 5;  // [27:31] 保留位
} DMA_CFG_REG_t;

// DMA_CUR_SRC_REG 位域结构体定义，来自技术手册p203 4.11.4.12 DMA Channel Current Source Address Register
typedef struct {
    uint32_t DMA_CUR_SRC_ADDR : 32;  // [0:31] DMA 通道当前源地址，只读
} DMA_CUR_SRC_REG_t;

// DMA_CUR_DEST_REG 位域结构体定义，来自技术手册p203 4.11.4.13 DMA Channel Current Destination Address Register
typedef struct {
    uint32_t DMA_CUR_DEST_ADDR : 32;  // [0:31] DMA 通道当前目的地址，只读
} DMA_CUR_DEST_REG_t;

// DMA_PARA_REG 位域结构体定义，来自技术手册p204 4.11.4.15 DMA Channel Parameter Register
typedef struct {
    uint32_t WAIT_CYC     : 8;   // [0:7] 等待时钟周期数，只读
    uint32_t RESERVED8_31 : 24;  // [8:31] 保留位
} DMA_PARA_REG_t;

```

具体实现如下：

```c
/*
 * DMA描述符准备函数
 * 功能: 为不同类型的DMA操作准备DMA描述符。
 */
static struct dma_async_tx_descriptor *hc_dma_prep_dma_memcpy(
        struct dma_chan *chan, dma_addr_t dest, dma_addr_t src, size_t len, unsigned long flags) {

    // 获取所需的两个指针，设备信息结构体和虚拟通道结构体
    DMA_DEV_Info *dma_dev = (DMA_DEV_Info *)(chan->device);
    DMA_Virtual_Channel_Info *vchan = (DMA_Virtual_Channel_Info *)chan;

    // 两种DMA描述符

    DMA_TASK_Descriptor *taskDesc;          // 软件（驱动程序）用的描述符
    DMA_HardWare_Descriptor *hardwareDesc;  // 硬件用的描述符

    if(len == 0) {
        // len是0，无效请求，直接返回NULL
        return NULL;
    }

    // 让内核分配软件描述符内存并初始化清空
    taskDesc = kzalloc(sizeof(*taskDesc), GFP_NOWAIT);
    if(!taskDesc) {
        // 这个不用说，失败返回
        return NULL;
    }
    memset(taskDesc, 0, sizeof(*taskDesc));

    // 通过DMA内存池分配内存（DMA内存池只能用来分配硬件描述符注意！）（第三个参数是分配给hardwareDesc的这块内存的物理地址）
    hardwareDesc = dma_pool_alloc(dma_dev->pool, GFP_NOWAIT, &(taskDesc->physical_addr));
    if (!hardwareDesc) {
        dev_err(dma_dev->slave.dev, "Failed to alloc DMA_HardWare_Descriptor memory\n");
        // 失败了就把任务描述符的内存释放了返回NULL
        kfree(taskDesc);
        return NULL;
    }
    memset(hardwareDesc, 0, sizeof(*hardwareDesc));

    // 把软件描述符的参数补完
    // 物理地址已经填上了，所以这里只需要补软件地址就行
    taskDesc->virtual_addr = hardwareDesc;

    // 配置硬件描述符各项参数
    hardwareDesc->src.DMA_CUR_SRC_ADDR = src;
    hardwareDesc->dst.DMA_CUR_DEST_ADDR = dest;
    hardwareDesc->len = len;
    hardwareDesc->para.WAIT_CYC = 8;            // 说明一下，按照参考驱动的源代码，普通等待时间被设置为8，这边有8位，范围就是 0 到 0xff = 255，不敢改，那就还是8吧
    hardwareDesc->p_next_dma_descriptor = DMA_DESCRIPTOR_END_ADDRESS;   // 当然没有下一个任务了
    hardwareDesc->v_next_dma_descriptor = NULL; // 同上

    hardwareDesc->cfg.DMA_SRC_DRQ_TYPE = 1;     // memcpy本来就只需要支持内存到内存，SDRAM是1，这个在数据手册p191页的表格4-1可以看到
    hardwareDesc->cfg.DMA_DEST_DRQ_TYPE = 1;    // 同上
    hardwareDesc->cfg.DMA_SRC_ADDR_MODE = 0;    // 内存当然是线性模式，这不用解释
    hardwareDesc->cfg.DMA_DEST_ADDR_MODE = 0;   // 同上
    hardwareDesc->cfg.DMA_SRC_BST_LEN = 2;      // 参考代码统一突发长度为8
    hardwareDesc->cfg.DMA_DEST_BST_LEN = 2;     // 同上
    hardwareDesc->cfg.DMA_SRC_DATA_WIDTH = 2;   // 源设备的总线位宽，32位内存当然是32
    hardwareDesc->cfg.DMA_DEST_DATA_WIDTH = 2;  // 同上

    // 让Linux的DMA驱动框架完成后续配置，这里不管了
    return vchan_tx_prep(&vchan->vc, &taskDesc->vd, flags);
}

```



#### 2.3.5 hc_dma_tx_status

这部分涉及到的是几个通道专用寄存器和一个特殊值。

```c
#define DMA_DESCRIPTOR_END_ADDRESS  0xFFFFF800  // DMA 描述符链结束标志，表示当前包为最后一个包

// DMA 通道专用寄存器 (N=0到11)
#define DMA_DESC_ADDR_REG_OFFSET(N) (0x100 + 0x40 * (N) + 0x08)     // DMA 通道开始地址寄存器 (N=0到11)
#define DMA_BCNT_LEFT_REG_OFFSET(N) (0x100 + 0x40 * (N) + 0x18)     // DMA 通道剩余字节计数器寄存器 (N=0到11)

```

实现如下：

```c
/*
 * DMA传输状态函数
 * 功能: 获取DMA传输的状态。
 */
static enum dma_status hc_dma_tx_status(
        struct dma_chan *chan, dma_cookie_t cookie, struct dma_tx_state *state) {

    // 获取所需的指针，虚拟通道结构体和物理通道结构体
    DMA_Virtual_Channel_Info *vchan = (DMA_Virtual_Channel_Info *)chan;
    DMA_Physical_Channel_Info *pchan = vchan->pchan;

    // 任务描述符和硬件描述符
    DMA_TASK_Descriptor *taskDesc;
    DMA_HardWare_Descriptor *hardwareDesc;

    unsigned long flags;    // 自旋锁保存中断上下文的变量
    size_t bytes;

    enum dma_status res;    // 返回结果，也就是DMA传输状态

    res = dma_cookie_status(chan, cookie, state);
    if (res == DMA_COMPLETE || !state) {
        // 已经有结果了直接返回
        return res;
    }
    // 这里是更新状态，状态是会变的，可能会被中断打断
    // 所以这里要加锁保护，保护这个状态更新过程（其实是bytes的计算过程）
    // 保护的粒度是这个虚拟通道，所以不能用设备锁
    spin_lock_irqsave(&vchan->vc.lock, flags);

    // 用框架给的函数找LinuxDMA引擎用的DMA任务描述符，将其转换为驱动程序里用的DMA_TASK_Descriptor
    taskDesc = (DMA_TASK_Descriptor *)vchan_find_desc(&vchan->vc, cookie);
    if(taskDesc == NULL) {
        // 找不到的话需要确认一下情况（一种是传输完毕，一种是正在传输）

        // 读当前通道开始地址寄存器，如果到达终点了就是描述符链结束标志
        if(ioread32(((DMA_DEV_Info *)(chan->device))->base_addr + DMA_DESC_ADDR_REG_OFFSET(pchan->index)) == DMA_DESCRIPTOR_END_ADDRESS) {
            // 都结束了，当然是0
            bytes = 0;
        } else {
            // 说明一下，通道剩余字节数量寄存器，那个显示的是当前这个数据包传输还剩多少个字节，不是该任务所有数据包
            bytes = ioread32(((DMA_DEV_Info *)(chan->device))->base_addr + DMA_BCNT_LEFT_REG_OFFSET(pchan->index));

            // 计算一下这批任务还剩多少个数据包，每个数据包多少个字节，加起来就是了
            hardwareDesc = taskDesc->virtual_addr;
            while(hardwareDesc != NULL) {
                bytes += hardwareDesc->len;
                hardwareDesc = hardwareDesc->v_next_dma_descriptor;
            }
        }

    } else {
        // 找得到意味着还没开始传输
        bytes = 0;
        // 直接计算一下这批任务还剩多少个数据包，每个数据包多少个字节，加起来就是了
        hardwareDesc = taskDesc->virtual_addr;
        while(hardwareDesc != NULL) {
            bytes += hardwareDesc->len;
            hardwareDesc = hardwareDesc->v_next_dma_descriptor;
        }
    }

    spin_unlock_irqrestore(&vchan->vc.lock, flags);
    dma_set_residue(state, bytes);  // 设置DMA传输操作中剩余未传输的数据量，就能更新状态了
    return res;
}

```



#### 2.3.6 hc_dma_issue_pending

```c
/*
 * DMA提交待处理函数
 * 功能: 提交待处理的DMA事务。
 */
static void hc_dma_issue_pending(struct dma_chan *chan) {
    // 获取所需的两个指针，设备信息结构体和虚拟通道结构体
    DMA_DEV_Info *dma_dev = (DMA_DEV_Info *)(chan->device);
    DMA_Virtual_Channel_Info *vchan = (DMA_Virtual_Channel_Info *)chan;
    // 自旋锁保存中断上下文所需的变量
    unsigned long flags;

    // 提交的对象是提交到哪条通道，所以要用通道锁保护
    spin_lock_irqsave(&vchan->vc.lock, flags);

    // 本质上是提交到Linux内核的DMA虚拟通道框架里面，让Linux去处理实际的事务过程
    if (vchan_issue_pending(&vchan->vc)) {
        // 因为要添加到大链表，也就是设备信息结构体的pending上，所以需要设备锁保护
        spin_lock(&dma_dev->lock);
        // 把当前这个通道的任务链表加到大链表末尾
        list_add_tail(&vchan->pending_node, &dma_dev->pending);
        // 这里是用tasklet_schedule来强行调度一次，不然没中断的话就永远调度不了了
        tasklet_schedule(&dma_dev->task);

        spin_unlock(&dma_dev->lock);
    } else {
        // 这种情况不正常，这是属于没提交事务的情况，不应该发生，要用dev_err打一下哪条虚拟通道出问题了
        dev_err(chan->device->dev, "DMA issue pending failed on virtual channel: %d\n", vchan->vc.chan.chan_id);
    }

    spin_unlock_irqrestore(&vchan->vc.lock, flags);
}

```



#### 2.3.7 hc_dma_tasklet

这里需要先实现 `hc_dma_tasklet` ，才知道 `hc_dma_start_transfer` 该干什么。

```c
/*
 * DMA Tasklet函数
 * 功能: 使用tasklet机制处理DMA操作中的任务调度和管理。
 */
static void hc_dma_tasklet(unsigned long data) {

    // data是传入的参数，是结构体指针
    DMA_DEV_Info *dma_dev = (DMA_DEV_Info *)(data);
    // 物理通道指针
    DMA_Physical_Channel_Info *pchan;
    // 虚拟通道指针
    DMA_Virtual_Channel_Info *vchan;
    // 计数器
    uint32_t i;

    // 首先确定哪个虚拟通道为空，将其变为初始化状态
    for(i = 0; i < dma_dev->cfg->max_virtual_channels; i++) {
        vchan = &(dma_dev->vchans[i]);
        // 因为操作的是通道，所以用通道锁保护，也怕中断，所以要用中断自旋锁
        spin_lock_irq(&vchan->vc.lock);
        if(vchan->pchan && vchan->pchan->done) {
            // 说明这条虚拟通道对应的物理通道至少传输过数据，当前虚拟通道的任务才可能已完成
            // 还需进一步判断
            if(vchan_next_desc(&(vchan->vc)) == NULL) {
                // 如果Linux系统的DMA虚拟通道框架认为这条虚拟通道已经没有下一个任务描述符了，说明任务已完成

                // 物理通道和虚拟通道解绑，物理通道空闲（不然没法进行剩下的任务）
                vchan->pchan->vchan = NULL;
                // 清空虚拟通道，虚拟通道初始化状态（不能真初始化，已经注册到虚拟通道框架去了，真初始化会出事，这里说的初始化是删所有能删的数据，vc不能删，其他都可以）
                vchan->pchan = NULL;
                list_del_init(&vchan->pending_node);
                vchan->port = 0;
                vchan->cyclic = 0;
                vchan->irq_type = 0;
                vchan->need_start = false;
                memset(&(vchan->cfg), 0, sizeof(vchan->cfg));
            }
        }
        spin_unlock_irq(&vchan->vc.lock);
    }

    // 任务提交的问题已经在hc_dma_issue_pending中提交上去了
    // hc_dma_issue_pending中把有任务的虚拟通道结点都链到大链表上了

    // 把空闲的物理通道分配给有任务的虚拟通道
    // 有任务，才需要分配，否则都没意义进入这个流程（增加循环进行条件，大链表不为空）

    // 物理通道是设备资源，要用设备锁保护
    spin_lock_irq(&dma_dev->lock);
    for (i = 0; i < dma_dev->cfg->max_physical_channels && !list_empty(&dma_dev->pending); i++) {
        pchan = &(dma_dev->pchans[i]);

        if (pchan->vchan) {
            // 绑定了一条虚拟通道，说明正在执行传输任务
            continue;
        }
        // 进入这个结点对应的vchan
        // 我觉得用contains_of没什么问题，但是保险起见专车专用吧
        vchan = list_first_entry(&dma_dev->pending, DMA_Virtual_Channel_Info, pending_node);

        // 有任务，就绑定两个通道
        pchan->vchan = vchan;
        vchan->pchan = pchan;
        // 然后把pending_node从链表中删掉，这样这个虚拟通道就不会被绑到其他通道上了
        list_del_init(&vchan->pending_node);
        // 需要启动传输任务的标记
        vchan->need_start = true;
    }
    spin_unlock_irq(&dma_dev->lock);

    // 分配了新任务，启动传输才有意义，不然没事找事容易出事
    for(i = 0; i < dma_dev->cfg->max_physical_channels; i++) {
        pchan = &(dma_dev->pchans[i]);
        // 只有物理通道绑定的虚拟通道才需要启动传输
        // 所以缩小范围，从物理通道来找
        vchan = pchan->vchan;

        if(vchan && vchan->need_start) {
            hc_dma_start_transfer(dma_dev, vchan);
        }
    }
}

```



#### 2.3.8 hc_dma_start_transfer

对应的结构体（寄存器结构）：

```c
// DMA IRQ 寄存器（中断请求寄存器）
#define DMA_IRQ_EN_REG0_OFFSET      0x00    // DMA IRQ 使能寄存器0
#define DMA_IRQ_EN_REG1_OFFSET      0x04    // DMA IRQ 使能寄存器1

// DMA 通道专用寄存器 (N=0到11)
#define DMA_EN_REG_OFFSET(N)        (0x100 + 0x40 * (N) + 0x00)     // DMA 通道使能寄存器 (N=0到11)
#define DMA_DESC_ADDR_REG_OFFSET(N) (0x100 + 0x40 * (N) + 0x08)     // DMA 通道开始地址寄存器 (N=0到11)


// DMA_IRQ_EN_REG0 位域结构体定义，来自技术手册p193 4.11.4.1 DMA IRQ Enable Register0
typedef struct {
    uint32_t DMA0_HLAF_IRQ_EN   : 1;  // [0] DMA 0 半包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA0_PKG_IRQ_EN    : 1;  // [1] DMA 0 完整包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA0_QUEUE_IRQ_EN  : 1;  // [2] DMA 0 队列结束传输中断使能位，0: 禁用，1: 使能
    uint32_t RESERVED3          : 1;  // [3] 保留未使用
    uint32_t DMA1_HLAF_IRQ_EN   : 1;  // [4] DMA 1 半包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA1_PKG_IRQ_EN    : 1;  // [5] DMA 1 完整包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA1_QUEUE_IRQ_EN  : 1;  // [6] DMA 1 队列结束传输中断使能位，0: 禁用，1: 使能
    uint32_t RESERVED7          : 1;  // [7] 保留未使用
    uint32_t DMA2_HLAF_IRQ_EN   : 1;  // [8] DMA 2 半包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA2_PKG_IRQ_EN    : 1;  // [9] DMA 2 完整包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA2_QUEUE_IRQ_EN  : 1;  // [10] DMA 2 队列结束传输中断使能位，0: 禁用，1: 使能
    uint32_t RESERVED11         : 1;  // [11] 保留未使用
    uint32_t DMA3_HLAF_IRQ_EN   : 1;  // [12] DMA 3 半包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA3_PKG_IRQ_EN    : 1;  // [13] DMA 3 完整包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA3_QUEUE_IRQ_EN  : 1;  // [14] DMA 3 队列结束传输中断使能位，0: 禁用，1: 使能
    uint32_t RESERVED15         : 1;  // [15] 保留未使用
    uint32_t DMA4_HLAF_IRQ_EN   : 1;  // [16] DMA 4 半包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA4_PKG_IRQ_EN    : 1;  // [17] DMA 4 完整包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA4_QUEUE_IRQ_EN  : 1;  // [18] DMA 4 队列结束传输中断使能位，0: 禁用，1: 使能
    uint32_t RESERVED19         : 1;  // [19] 保留未使用
    uint32_t DMA5_HLAF_IRQ_EN   : 1;  // [20] DMA 5 半包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA5_PKG_IRQ_EN    : 1;  // [21] DMA 5 完整包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA5_QUEUE_IRQ_EN  : 1;  // [22] DMA 5 队列结束传输中断使能位，0: 禁用，1: 使能
    uint32_t RESERVED23         : 1;  // [23] 保留未使用
    uint32_t DMA6_HLAF_IRQ_EN   : 1;  // [24] DMA 6 半包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA6_PKG_IRQ_EN    : 1;  // [25] DMA 6 完整包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA6_QUEUE_IRQ_EN  : 1;  // [26] DMA 6 队列结束传输中断使能位，0: 禁用，1: 使能
    uint32_t RESERVED27         : 1;  // [27] 保留未使用
    uint32_t DMA7_HLAF_IRQ_EN   : 1;  // [28] DMA 7 半包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA7_PKG_IRQ_EN    : 1;  // [29] DMA 7 完整包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA7_QUEUE_IRQ_EN  : 1;  // [30] DMA 7 队列结束传输中断使能位，0: 禁用，1: 使能
    uint32_t RESERVED31         : 1;  // [31] 保留未使用
} DMA_IRQ_EN_REG0_t;

// DMA_IRQ_EN_REG1 位域结构体定义，来自技术手册p195 4.11.4.2 DMA IRQ Enable Register1
typedef struct {
    uint32_t DMA8_HLAF_IRQ_EN    : 1;  // [0] DMA 8 半包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA8_PKG_IRQ_EN     : 1;  // [1] DMA 8 完整包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA8_QUEUE_IRQ_EN   : 1;  // [2] DMA 8 队列结束传输中断使能位，0: 禁用，1: 使能
    uint32_t RESERVED3           : 1;  // [3] 保留未使用
    uint32_t DMA9_HLAF_IRQ_EN    : 1;  // [4] DMA 9 半包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA9_PKG_IRQ_EN     : 1;  // [5] DMA 9 完整包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA9_QUEUE_IRQ_EN   : 1;  // [6] DMA 9 队列结束传输中断使能位，0: 禁用，1: 使能
    uint32_t RESERVED7           : 1;  // [7] 保留未使用
    uint32_t DMA10_HLAF_IRQ_EN   : 1;  // [8] DMA 10 半包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA10_PKG_IRQ_EN    : 1;  // [9] DMA 10 完整包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA10_QUEUE_IRQ_EN  : 1;  // [10] DMA 10 队列结束传输中断使能位，0: 禁用，1: 使能
    uint32_t RESERVED11          : 1;  // [11] 保留未使用
    uint32_t DMA11_HLAF_IRQ_EN   : 1;  // [12] DMA 11 半包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA11_PKG_IRQ_EN    : 1;  // [13] DMA 11 完整包传输中断使能位，0: 禁用，1: 使能
    uint32_t DMA11_QUEUE_IRQ_EN  : 1;  // [14] DMA 11 队列结束传输中断使能位，0: 禁用，1: 使能
    uint32_t RESERVED15_31       : 17; // [15:31] 保留未使用
} DMA_IRQ_EN_REG1_t;

// DMA_EN_REG 位域结构体定义，来自技术手册p202 4.11.4.8 DMA Channel Enable Register
typedef struct {
    uint32_t DMA_EN      : 1;  // [0] DMA 通道使能，0: 禁用，1: 使能
    uint32_t RESERVED1_31: 31; // [1:31] 保留未使用
} DMA_EN_REG_t;

// DMA_DESC_ADDR_REG 位域结构体定义，来自技术手册p203 4.11.4.10 DMA Channel Descriptor Address Register
typedef struct {
    uint32_t DMA_DESC_ADDR : 32; // [0:31] DMA 通道描述符地址，必须是字对齐的
} DMA_DESC_ADDR_REG_t;

```

实现过程：

```c
/*
 * DMA传输启动函数
 * 功能: 启动DMA传输操作。
 */
static int hc_dma_start_transfer(DMA_DEV_Info *dma_dev, DMA_Virtual_Channel_Info *vchan) {

    struct virt_dma_desc *desc = vchan_next_desc(&vchan->vc);
    DMA_Physical_Channel_Info *pchan;
    uint32_t reg_value;

    // 先判断，怕出事
    if(!dma_dev || !vchan || !desc || !(vchan->need_start)) {
        return -EAGAIN;
    }

    // 涉及这个通道的操作，所以需要用通道锁保护
    spin_lock_irq(&vchan->vc.lock);

    // 首先把通道的标记改了
    vchan->need_start = false;
    
    // 再把这个任务结点从虚拟DMA框架的任务描述符里面删了（不然虚拟DMA框架认为这个任务还是这个虚拟通道的任务）
    list_del(&desc->node);

    pchan = vchan->pchan;
    pchan->todo = (DMA_TASK_Descriptor *)desc;
    pchan->done = NULL;

    // 按照参考的驱动代码的做法
    // IRQ类型是根据是否循环DMA来确定的，如果是循环DMA，就单开全包中断，如果不是循环DMA，就单开队列结束中断，也就是如下
    // vchan->irq_type = vchan->cyclic ? DMA_IRQ_PKG : DMA_IRQ_QUEUE;
    // 似乎没考虑半包中断，那我也不用考虑了，仿照就是了，后面可能尝试实现半包中断

    // 半包是位0，全包是位1，队列是位2
    // 单开全包是1，单开全包是 1 << 1 = 2，单开队列是1 << 2 = 4
    vchan->irq_type = vchan->cyclic ? 2 : 4;

    // 开启对应通道的IRQ中断，一个寄存器放8个通道的中断位
    // 因为我这里目前只有H3，所以我也只考虑H3的情况（12个通道，分两组，前一组8个，后一组4个）
    if(pchan->index < 8) {
        // 第一组
        reg_value = ioread32(dma_dev->base_addr + DMA_IRQ_EN_REG0_OFFSET);
        // 如果是0号通道，那就是0到2一共三个位置为0（第四个位保留，永远为0）
        // 三个位置全部为1的时候是7（7的二进制是111）
        // 如果是1号通道，那就是4到6一共是三个位置，那就是7 << 4 * 1，以此类推

        reg_value &= ~(7 << (4 * pchan->index));  // 位与按位取反，清除对应位的值
        reg_value |= (vchan->irq_type << (4 *  pchan->index));  // 设置指定值


        iowrite32(reg_value, dma_dev->base_addr + DMA_IRQ_EN_REG0_OFFSET);
    } else {
        // 第二组
        reg_value = ioread32(dma_dev->base_addr + DMA_IRQ_EN_REG1_OFFSET);

        reg_value &= ~(7 << (4 * (pchan->index - 8)));  // 位与按位取反，清除对应位的值
        reg_value |= (vchan->irq_type << (4 *  (pchan->index - 8)));    // 设置指定值

        iowrite32(reg_value, dma_dev->base_addr + DMA_IRQ_EN_REG1_OFFSET);
    }

    // 把对应的开始地址写到DMA通道开始地址寄存器
    iowrite32(pchan->todo->physical_addr,dma_dev->base_addr + DMA_DESC_ADDR_REG_OFFSET(pchan->index));
    // 开启传输
    iowrite32(1, dma_dev->base_addr + DMA_EN_REG_OFFSET(pchan->index));

    spin_unlock_irq(&vchan->vc.lock);

    return 0;  // 成功启动传输
}

```



#### 2.3.9 hc_dma_stop_transfer

```c
/*
 * DMA传输停止函数
 * 功能: 停止DMA传输操作。
 */
static void hc_dma_stop_transfer(DMA_DEV_Info *dma_dev, DMA_Virtual_Channel_Info *vchan) {
    // 这个DMA不用停止，硬件描述符到头自动停止，因此保持原样
}

```



#### 2.3.10 hc_dma_interrupt

之前在probe中申请中断的时候，过程是：

```c
    // 向内核申请对应的IRQ中断，参数是设备、中断号、中断处理函数、设备名、设备数据
    ret = devm_request_irq(&pdev->dev, dma_dev->irq, hc_dma_interrupt, 0, pdev->name, dma_dev);
    if (ret) {
        dev_err(&pdev->dev, "Failed to request IRQ\n");
        return ret;
    }

```

最后一个参数设备数据，给的其实就是hc_dma_interrupt的第二个参数（第一个参数irq号是系统用的，驱动用不到），dev_id的意义就这么回事。

涉及到的寄存器及其结构：

```c
// DMA IRQ 寄存器（中断请求寄存器）
#define DMA_IRQ_PEND_REG0_OFFSET    0x10    // DMA IRQ 挂起寄存器0
#define DMA_IRQ_PEND_REG1_OFFSET    0x14    // DMA IRQ 挂起寄存器1

// DMA_IRQ_PEND_REG0 位域结构体定义，来自技术手册p196 4.11.4.3 DMA IRQ Pending Status Register0
typedef struct {
    uint32_t DMA0_HLAF_IRQ_PEND   : 1;  // [0] DMA 0 半包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA0_PKG_IRQ_PEND    : 1;  // [1] DMA 0 完整包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA0_QUEUE_IRQ_PEND  : 1;  // [2] DMA 0 队列结束传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t RESERVED3            : 1;  // [3] 保留未使用
    uint32_t DMA1_HLAF_IRQ_PEND   : 1;  // [4] DMA 1 半包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA1_PKG_IRQ_PEND    : 1;  // [5] DMA 1 完整包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA1_QUEUE_IRQ_PEND  : 1;  // [6] DMA 1 队列结束传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t RESERVED7            : 1;  // [7] 保留未使用
    uint32_t DMA2_HLAF_IRQ_PEND   : 1;  // [8] DMA 2 半包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA2_PKG_IRQ_PEND    : 1;  // [9] DMA 2 完整包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA2_QUEUE_IRQ_PEND  : 1;  // [10] DMA 2 队列结束传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t RESERVED11           : 1;  // [11] 保留未使用
    uint32_t DMA3_HLAF_IRQ_PEND   : 1;  // [12] DMA 3 半包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA3_PKG_IRQ_PEND    : 1;  // [13] DMA 3 完整包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA3_QUEUE_IRQ_PEND  : 1;  // [14] DMA 3 队列结束传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t RESERVED15           : 1;  // [15] 保留未使用
    uint32_t DMA4_HLAF_IRQ_PEND   : 1;  // [16] DMA 4 半包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA4_PKG_IRQ_PEND    : 1;  // [17] DMA 4 完整包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA4_QUEUE_IRQ_PEND  : 1;  // [18] DMA 4 队列结束传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t RESERVED19           : 1;  // [19] 保留未使用
    uint32_t DMA5_HLAF_IRQ_PEND   : 1;  // [20] DMA 5 半包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA5_PKG_IRQ_PEND    : 1;  // [21] DMA 5 完整包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA5_QUEUE_IRQ_PEND  : 1;  // [22] DMA 5 队列结束传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t RESERVED23           : 1;  // [23] 保留未使用
    uint32_t DMA6_HLAF_IRQ_PEND   : 1;  // [24] DMA 6 半包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA6_PKG_IRQ_PEND    : 1;  // [25] DMA 6 完整包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA6_QUEUE_IRQ_PEND  : 1;  // [26] DMA 6 队列结束传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t RESERVED27           : 1;  // [27] 保留未使用
    uint32_t DMA7_HLAF_IRQ_PEND   : 1;  // [28] DMA 7 半包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA7_PKG_IRQ_PEND    : 1;  // [29] DMA 7 完整包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA7_QUEUE_IRQ_PEND  : 1;  // [30] DMA 7 队列结束传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t RESERVED31           : 1;  // [31] 保留未使用
} DMA_IRQ_PEND_REG0_t;

// DMA_IRQ_PEND_REG1 位域结构体定义，来自技术手册p198 4.11.4.4 DMA IRQ Pending Status Register1
typedef struct {
    uint32_t DMA8_HLAF_IRQ_PEND    : 1;  // [0] DMA 8 半包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA8_PKG_IRQ_PEND     : 1;  // [1] DMA 8 完整包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA8_QUEUE_IRQ_PEND   : 1;  // [2] DMA 8 队列结束传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t RESERVED3             : 1;  // [3] 保留未使用
    uint32_t DMA9_HLAF_IRQ_PEND    : 1;  // [4] DMA 9 半包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA9_PKG_IRQ_PEND     : 1;  // [5] DMA 9 完整包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA9_QUEUE_IRQ_PEND   : 1;  // [6] DMA 9 队列结束传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t RESERVED7             : 1;  // [7] 保留未使用
    uint32_t DMA10_HLAF_IRQ_PEND   : 1;  // [8] DMA 10 半包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA10_PKG_IRQ_PEND    : 1;  // [9] DMA 10 完整包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA10_QUEUE_IRQ_PEND  : 1;  // [10] DMA 10 队列结束传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t RESERVED11            : 1;  // [11] 保留未使用
    uint32_t DMA11_HLAF_IRQ_PEND   : 1;  // [12] DMA 11 半包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA11_PKG_IRQ_PEND    : 1;  // [13] DMA 11 完整包传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t DMA11_QUEUE_IRQ_PEND  : 1;  // [14] DMA 11 队列结束传输中断挂起，0: 无效，1: 挂起（设置为1时清除挂起位）
    uint32_t RESERVED15_31         : 17; // [15:31] 保留未使用
} DMA_IRQ_PEND_REG1_t;

```

实现过程：

```c
/*
 * DMA中断处理程序
 * 功能: 处理DMA控制器产生的中断。
 */
static irqreturn_t hc_dma_interrupt(int irq, void *dev_id) {
    // dev_id就是传入的设备信息指针dma_dev
    DMA_DEV_Info *dma_dev = (DMA_DEV_Info *)dev_id;
    DMA_Physical_Channel_Info *pchan;   // 物理通道指针
    DMA_Virtual_Channel_Info *vchan;    // 虚拟通道指针
    uint32_t reg_value;                 // 寄存器值
    uint32_t ret = IRQ_NONE;            // 返回值，默认为没有IRQ中断
    uint32_t i;                         // 计数器

    // 需要查看的是IRQ挂起寄存器
    // 结构和使能寄存器类似

    // 第一组
    reg_value = ioread32(dma_dev->base_addr + DMA_IRQ_PEND_REG0_OFFSET);
    if(reg_value != 0) {
        // 不等于0，这一组才有需要清除中断的，否则不需要
        // 根据技术手册，写对应位为1即清除中断，写0不变
        // 直接原封不动写回去就行了
        iowrite32(reg_value, dma_dev->base_addr + DMA_IRQ_PEND_REG0_OFFSET);
        // 然后判断是哪个通道的什么中断挂起了，更新状态

        // 参考hc_dma_start_transfer中，清除对应位的做法
        // 这一个寄存器有8个物理通道的状态
        for(i = 0; i < 8; i++) {
            if (reg_value & (7 << (i * 4))) {
                // 只要不是完全等于0就找到打出中断的物理通道下标
                // 明确物理通道下标之后，判断是否需要更新状态
                pchan = &(dma_dev->pchans[i]);
                vchan = pchan->vchan;

                // 要判断是否符合那个通道的中断要求
                // 只要允许的中断类型出现就行，没必要完全符合
                // 所以把值右移，再位与irq_type，只要不为0，说明有符合的
                if( (reg_value >> (i * 4)) & vchan->irq_type ) {
                    // 这个版本暂时不支持循环DMA，所以不考虑这个情况
                    // 操作通道，自然要上通道锁保护
                    spin_lock(&vchan->vc.lock);
                    // 更新任务状态
                    vchan_cookie_complete(&pchan->todo->vd);
                    // 更新任务指针
                    pchan->done = pchan->todo;
                    pchan->todo = NULL;
                    spin_unlock(&vchan->vc.lock);
                }
            }
        }

        // 已经处理了一组，尝试调度一次
        if (atomic_read(&dma_dev->tasklet_shutdown) == 0) {
            // 只要没停止，就可以尝试调度
            tasklet_schedule(&dma_dev->task);
        }

        ret = IRQ_HANDLED;
    }

    // 第二组同上
    reg_value = ioread32(dma_dev->base_addr + DMA_IRQ_PEND_REG1_OFFSET);
    if(reg_value != 0) {
        iowrite32(reg_value, dma_dev->base_addr + DMA_IRQ_PEND_REG1_OFFSET);
        // 不同的是这一个寄存器有4个物理通道的状态
        for(i = 0; i < 4; i++) {
            if (reg_value & (7 << (i * 4))) {
                pchan = &(dma_dev->pchans[i + 8]);
                vchan = pchan->vchan;
                if( (reg_value >> (i * 4)) & vchan->irq_type ) {
                    spin_lock(&vchan->vc.lock);
                    vchan_cookie_complete(&pchan->todo->vd);
                    pchan->done = pchan->todo;
                    pchan->todo = NULL;
                    spin_unlock(&vchan->vc.lock);
                }
            }
        }
        if (atomic_read(&dma_dev->tasklet_shutdown) == 0) {
            tasklet_schedule(&dma_dev->task);
        }
        ret = IRQ_HANDLED;
    }

    // 返回结果
    return ret;
}

```



## 3. 上机测试

直接说结果吧，完全成功。

```bash
/ # cd home
/home # insmod hc_opi_one_dma.ko
[   29.150745] hc_opi_one_dma: loading out-of-tree module taints kernel.
/home # lsmod
hc_opi_one_dma 20480 0 - Live 0xbf000000 (O)
/home # insmod dma_test.ko
[   42.368708] Initializing DMA test module
[   42.372745] DMA test started
[   42.375769] DMA transfer completed
[   42.379237] DMA test finished successfully
/home # lsmod
dma_test 16384 0 - Live 0xbf00a000 (O)
hc_opi_one_dma 20480 0 - Live 0xbf000000 (O)
/home # rmmod dma_test
[   57.406334] Exiting DMA test module
/home # insmod dma_test.ko
[   66.919300] Initializing DMA test module
[   66.923252] DMA test started
[   66.926270] DMA transfer completed
[   66.929750] DMA test finished successfully
/home # rmmod dma_test
[   73.171483] Exiting DMA test module

```

单次测试过关。

多次测试过关。

完全可以进行内存到内存间的传输
