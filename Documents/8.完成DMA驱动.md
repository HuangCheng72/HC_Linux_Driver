# 八：完成DMA驱动



## 1. 通道控制函数

其实就是这三个

```c
/*
 * DMA通道控制函数
 * 功能: 控制DMA通道的暂停、恢复和终止操作。
 */
static int hc_dma_pause(struct dma_chan *chan) {
    return 0;  // 返回成功
}

static int hc_dma_resume(struct dma_chan *chan) {
    return 0;  // 返回成功
}

static int hc_dma_terminate_all(struct dma_chan *chan) {
    return 0;  // 返回成功
}
```

分两部分进行。

这三个函数总的来说比较简单，不需要测试，逻辑上都能测试通过了。



### 1.1 暂停和恢复

这两个是互逆关系，自然要放在一起说。

```c
/*
 * DMA通道控制函数
 * 功能: 控制DMA通道的暂停、恢复和终止操作。
 */
static int hc_dma_pause(struct dma_chan *chan) {
    // 需要明确的是：
    // 1. 操作的通道对象实际上是虚拟通道
    // 2. 既然是虚拟通道，那就要分是否有物理通道（正在进行传输）和没有物理通道（等待进行传输）的情况
    // 3. 有物理通道，那自然就要写物理通道寄存器（既然是暂停，任务还是要继续的，所以不能解绑物理通道和虚拟通道，不缺这点资源）
    // 4. 没有物理通道，那就直接把该通道从等待队列里面删掉，不需要再分配物理通道了
    // 对于4.这种情况来说，考虑到tasklet中，分配物理通道的判断条件是!list_empty(&dma_dev->pending)，是从dma_dev->pending里面取对应的有任务的物理通道
    // 所以直接把这个结点从大链表中删掉就行了

    // 获取设备信息和通道的指针
    DMA_DEV_Info *dma_dev = (DMA_DEV_Info *)(chan->device);
    DMA_Virtual_Channel_Info *vchan = (DMA_Virtual_Channel_Info *)chan;
    DMA_Physical_Channel_Info *pchan = vchan->pchan;
    uint32_t reg_value;
    // 这样就可以用结构体直接写寄存器值的特定位了
    DMA_PAU_REG_t *dmaPauReg = (DMA_PAU_REG_t *)(&reg_value);

    if(pchan) {
        // 读对应的物理通道寄存器
        reg_value = ioread32(dma_dev->base_addr + DMA_PAU_REG_OFFSET(pchan->index));
        // 修改暂停位，暂停传输
        dmaPauReg->DMA_PAUSE = 1;
        // 写回寄存器
        iowrite32(reg_value, dma_dev->base_addr + DMA_PAU_REG_OFFSET(pchan->index));

    } else {
        // 操作的是大链表，自然要用设备锁保护
        spin_lock(&dma_dev->lock);
        // 直接把这个通道的结点从大链表中删掉就行了
        list_del_init(&vchan->pending_node);

        spin_unlock(&dma_dev->lock);
    }

    return 0;  // 返回成功
}

static int hc_dma_resume(struct dma_chan *chan) {
    // hc_dma_pause的反操作，反过来就行了

    // 获取设备信息和通道的指针
    DMA_DEV_Info *dma_dev = (DMA_DEV_Info *)(chan->device);
    DMA_Virtual_Channel_Info *vchan = (DMA_Virtual_Channel_Info *)chan;
    DMA_Physical_Channel_Info *pchan = vchan->pchan;
    uint32_t reg_value;
    // 这样就可以用结构体直接写寄存器值的特定位了
    DMA_PAU_REG_t *dmaPauReg = (DMA_PAU_REG_t *)(&reg_value);

    if(pchan) {
        // 读对应的物理通道寄存器
        reg_value = ioread32(dma_dev->base_addr + DMA_PAU_REG_OFFSET(pchan->index));
        // 修改暂停位，恢复传输
        dmaPauReg->DMA_PAUSE = 0;
        // 写回寄存器
        iowrite32(reg_value, dma_dev->base_addr + DMA_PAU_REG_OFFSET(pchan->index));

    } else {
        // 操作的是大链表，自然要用设备锁保护
        spin_lock(&dma_dev->lock);
        // 直接把这个通道的结点加回到大链表中就行了
        list_add_tail(&vchan->pending_node, &dma_dev->pending);

        spin_unlock(&dma_dev->lock);
    }

    return 0;  // 返回成功
}

```



### 1.2 终止操作

```c
static int hc_dma_terminate_all(struct dma_chan *chan) {

    // 获取设备信息和通道的指针
    DMA_DEV_Info *dma_dev = (DMA_DEV_Info *)(chan->device);
    DMA_Virtual_Channel_Info *vchan = (DMA_Virtual_Channel_Info *)chan;
    DMA_Physical_Channel_Info *pchan = vchan->pchan;
    // 要直接操作虚拟通道信息，用到spin_lock_irqsave，因此需要保存上下文的变量
    unsigned long flags;

    uint32_t reg_value;
    // 这样就可以用结构体直接写寄存器值的特定位了
    DMA_EN_REG_t *dmaEnReg = (DMA_EN_REG_t *)(&reg_value);
    DMA_PAU_REG_t *dmaPauReg = (DMA_PAU_REG_t *)(&reg_value);

    // 创建一个头结点，用于获取虚拟通道的任务描述符链表，并将其销毁
    LIST_HEAD(desc_head);

    if(pchan) {

        // 要变更虚拟通道资源，所以需要通道锁保护
        spin_lock_irqsave(&vchan->vc.lock, flags);

        // 如果物理通道已经绑定，写寄存器以终止传输
        // 首先恢复传输（如果先前是暂停状态，恢复传输才可以真正停止），然后禁用通道传输功能
        // 如此才能真正停止传输

        // 该通道恢复传输
        reg_value = ioread32(dma_dev->base_addr + DMA_PAU_REG_OFFSET(pchan->index));
        dmaPauReg->DMA_PAUSE = 0;
        iowrite32(reg_value, dma_dev->base_addr + DMA_PAU_REG_OFFSET(pchan->index));

        // 禁用物理通道（hc_dma_start_transfer中会启用，所以不用担心）
        reg_value = ioread32(dma_dev->base_addr + DMA_EN_REG_OFFSET(pchan->index));
        dmaEnReg->DMA_EN = 0;
        iowrite32(reg_value, dma_dev->base_addr + DMA_EN_REG_OFFSET(pchan->index));

        // 对于循环DMA通道，需要特殊处理
        if (vchan->cyclic) {
            // 循环的属性去掉
            vchan->cyclic = false;

            // 将已完成的任务加入到虚拟通道的已完成描述符链表中
            // 这是因为循环DMA不会自动完成传输（这是其特性）
            // 必须手动标记已完成的任务，以便框架正确处理和释放资源
            if(pchan->todo) {
                list_add_tail(&(pchan->todo->vd.node), &(vchan->vc.desc_completed));
            }
        }

        // 清理物理通道资源
        pchan->todo = NULL;
        pchan->done = NULL;
        // 解绑物理通道和虚拟通道
        pchan->vchan = NULL;
        vchan->pchan = NULL;

        spin_unlock_irqrestore(&vchan->vc.lock, flags);

    } else {
        // 没任务可传输，直接从大链表中删掉
        spin_lock(&dma_dev->lock);
        list_del_init(&vchan->pending_node);
        spin_unlock(&dma_dev->lock);
    }

    // 然后回收任务描述符

    // 属于虚拟通道的资源，需要通道锁保护
    spin_lock_irqsave(&vchan->vc.lock, flags);

    // 把所有的描述符转移到新链表头结点上（Linux内核虚拟通道支持框架提供的函数）
    vchan_get_all_descriptors(&vchan->vc, &desc_head);


    spin_unlock_irqrestore(&vchan->vc.lock, flags);

    // 不属于虚拟通道之后，就可以不用通道锁保护了

    // 让虚拟DMA通道框架释放描述符链表上的所有描述符
    vchan_dma_desc_free_list(&vchan->vc, &desc_head);

    return 0;  // 返回成功
}

```

需要解释一下：

在非循环模式下，任务自然会完成，并且被自动添加到 `desc_completed` 列表中。但在循环模式下，任务不会“完成”，所以需要手动将它加入已完成的列表 `desc_completed` ，以便Linux的DMA引擎框架可以处理和释放它。



## 2. 实现设备之间的DMA传输



### 2.1 概念解释

**Scatter-Gather**是用于数据传输的一种机制，常见于DMA（Direct Memory Access）传输中。它的核心思想是处理**非连续**的内存块，而不是传统的连续内存传输。Scatter-Gather模式主要涉及以下两个操作：

- **Scatter（分散）**：从连续的源内存块传输数据到多个目标内存块，这些目标内存块可能是不连续的。
- **Gather（聚集）**：从多个非连续的源内存块聚集数据到一个连续的目标内存块。

很多时候数据可能存储在内存的不同位置，通过Scatter-Gather，可以避免将它们搬移到一个连续的区域，再进行DMA传输。

```c
static struct dma_async_tx_descriptor *hc_dma_prep_slave_sg(
        struct dma_chan *chan, struct scatterlist *sgl, unsigned int sg_len,
        enum dma_transfer_direction dir, unsigned long flags, void *context) {
    return NULL;  // 暂时不支持此操作
}

```

新的参数意义解释：

`sgl`: 描述不连续内存块的`scatterlist`，用于进行Scatter-Gather操作。

`sg_len`: `scatterlist`中内存块的数量，控制遍历的次数。

`dir`: 数据传输的方向（内存到设备或设备到内存）。

`flags`: 传输的控制标志，影响DMA传输行为。

`context`: 用于传递额外的上下文信息，通常在DMA完成后的回调中使用。



在这个函数体，根据方向的不同，分两种情况：

**内存到设备（DMA_MEM_TO_DEV）**：源地址是`scatterlist`中的地址，目标地址是设备的地址。

**设备到内存（DMA_DEV_TO_MEM）**：源地址是设备的地址，目标地址是`scatterlist`中的地址。

因此函数实现必须同时处理这两种情况。



### 2.2 实现过程

既然要支持 `Scatter-Gather` ，那么就必须考虑到，要把所有的描述符都囊括在内。

因此，就需要一个描述符链了。之前在硬件描述符和任务描述符中预留的下一个描述符的地址，此时就派上用场了。

`scatterlist` 结构体如下，这个结构体位于 `linux-4.9/include/linux/scatterlist.h` 中。

```c
struct scatterlist {
#ifdef CONFIG_DEBUG_SG
	unsigned long	sg_magic;
#endif
	unsigned long	page_link;
	unsigned int	offset;
	unsigned int	length;
	dma_addr_t	dma_address;
#ifdef CONFIG_NEED_SG_DMA_LENGTH
	unsigned int	dma_length;
#endif
};
```

这个头文件还提供了一些宏：

```c
/*
 * These macros should be used after a dma_map_sg call has been done
 * to get bus addresses of each of the SG entries and their lengths.
 * You should only work with the number of sg entries dma_map_sg
 * returns, or alternatively stop on the first sg_dma_len(sg) which
 * is 0.
 */
#define sg_dma_address(sg)	((sg)->dma_address)

#ifdef CONFIG_NEED_SG_DMA_LENGTH
#define sg_dma_len(sg)		((sg)->dma_length)
#else
#define sg_dma_len(sg)		((sg)->length)
#endif
/*
 * Loop over each sg element, following the pointer to a new list if necessary
 */
#define for_each_sg(sglist, sg, nr, __i)	\
	for (__i = 0, sg = (sglist); __i < (nr); __i++, sg = sg_next(sg))

```

这里需要真正从 `dma_slave_config` 结构体里面提取信息了，这个结构体位于 `linux-4.9/include/linux/dmaengine.h` 中。

```c
/**
 * struct dma_slave_config - dma slave channel runtime config
 * @direction: whether the data shall go in or out on this slave
 * channel, right now. DMA_MEM_TO_DEV and DMA_DEV_TO_MEM are
 * legal values. DEPRECATED, drivers should use the direction argument
 * to the device_prep_slave_sg and device_prep_dma_cyclic functions or
 * the dir field in the dma_interleaved_template structure.
 * @src_addr: this is the physical address where DMA slave data
 * should be read (RX), if the source is memory this argument is
 * ignored.
 * @dst_addr: this is the physical address where DMA slave data
 * should be written (TX), if the source is memory this argument
 * is ignored.
 * @src_addr_width: this is the width in bytes of the source (RX)
 * register where DMA data shall be read. If the source
 * is memory this may be ignored depending on architecture.
 * Legal values: 1, 2, 4, 8.
 * @dst_addr_width: same as src_addr_width but for destination
 * target (TX) mutatis mutandis.
 * @src_maxburst: the maximum number of words (note: words, as in
 * units of the src_addr_width member, not bytes) that can be sent
 * in one burst to the device. Typically something like half the
 * FIFO depth on I/O peripherals so you don't overflow it. This
 * may or may not be applicable on memory sources.
 * @dst_maxburst: same as src_maxburst but for destination target
 * mutatis mutandis.
 * @device_fc: Flow Controller Settings. Only valid for slave channels. Fill
 * with 'true' if peripheral should be flow controller. Direction will be
 * selected at Runtime.
 * @slave_id: Slave requester id. Only valid for slave channels. The dma
 * slave peripheral will have unique id as dma requester which need to be
 * pass as slave config.
 *
 * This struct is passed in as configuration data to a DMA engine
 * in order to set up a certain channel for DMA transport at runtime.
 * The DMA device/engine has to provide support for an additional
 * callback in the dma_device structure, device_config and this struct
 * will then be passed in as an argument to the function.
 *
 * The rationale for adding configuration information to this struct is as
 * follows: if it is likely that more than one DMA slave controllers in
 * the world will support the configuration option, then make it generic.
 * If not: if it is fixed so that it be sent in static from the platform
 * data, then prefer to do that.
 */
struct dma_slave_config {
	enum dma_transfer_direction direction;
	phys_addr_t src_addr;
	phys_addr_t dst_addr;
	enum dma_slave_buswidth src_addr_width;
	enum dma_slave_buswidth dst_addr_width;
	u32 src_maxburst;
	u32 dst_maxburst;
	bool device_fc;
	unsigned int slave_id;
};
```

还有设备位宽：

```c
/**
 * enum dma_slave_buswidth - defines bus width of the DMA slave
 * device, source or target buses
 */
enum dma_slave_buswidth {
	DMA_SLAVE_BUSWIDTH_UNDEFINED = 0,
	DMA_SLAVE_BUSWIDTH_1_BYTE = 1,
	DMA_SLAVE_BUSWIDTH_2_BYTES = 2,
	DMA_SLAVE_BUSWIDTH_3_BYTES = 3,
	DMA_SLAVE_BUSWIDTH_4_BYTES = 4,
	DMA_SLAVE_BUSWIDTH_8_BYTES = 8,
	DMA_SLAVE_BUSWIDTH_16_BYTES = 16,
	DMA_SLAVE_BUSWIDTH_32_BYTES = 32,
	DMA_SLAVE_BUSWIDTH_64_BYTES = 64,
};
```



涉及到虚拟通道的端口，虚拟通道分配的时候，从设备树中获取对应的设备，其实已经把端口写入port了，在这里就用上了。

```c
// 该函数从设备树中解析 DMA 请求并返回一个可用的 DMA 通道，同时将通道与指定的端口号关联。
static struct dma_chan *hc_dma_of_xlate(struct of_phandle_args *dma_spec, struct of_dma *ofdma) {
    DMA_DEV_Info *dma_dev = ofdma->of_dma_data;
    struct dma_chan *chan;

    // dma_spec->args[0]存储的是设备树中指定的DMA请求端口
    uint32_t port = dma_spec->args[0];

    // 判断端口是否越界
    if (port > dma_dev->cfg->max_requests) {
        return NULL;
    }

    // 获取任意一个可用的DMA通道
    chan = dma_get_any_slave_channel(&dma_dev->slave);
    if (!chan) {
        return NULL;
    }

    // 虚拟通道对应到该设备的端口，并写入结构体成员中
    ((DMA_Virtual_Channel_Info *)chan)->port = port;

    return chan;
}

```

具体实现过程：

```c
static struct dma_async_tx_descriptor *hc_dma_prep_slave_sg(
        struct dma_chan *chan, struct scatterlist *sgl, unsigned int sg_len,
        enum dma_transfer_direction dir, unsigned long flags, void *context) {

    // 其实它们都类似，只是描述符的配置不太相同
    // 本质上来说，真正的差异还是描述符的各项配置
    // 因此可以直接从memcpy里面复制代码下来改

    // 获取所需的两个指针，设备信息结构体和虚拟通道结构体
    DMA_DEV_Info *dma_dev = (DMA_DEV_Info *)(chan->device);
    DMA_Virtual_Channel_Info *vchan = (DMA_Virtual_Channel_Info *)chan;

    // 两种DMA描述符

    DMA_TASK_Descriptor *taskDesc;          // 软件（驱动程序）用的描述符
    DMA_HardWare_Descriptor *hardwareDesc;  // 硬件用的描述符

    DMA_HardWare_Descriptor *tail = NULL;   // 为了串到链表尾结点用到

    DMA_HardWare_Descriptor *temp_hardwareDesc; // 销毁描述符的时候用到的变量

    // 描述符物理地址
    dma_addr_t physical_addr;

    // sg链表结点
    struct scatterlist *sg_node;

    // 计数器
    uint32_t i;

    // 通道参数，每个描述符都用得到
    uint32_t src_width;
    uint32_t dest_width;
    uint32_t src_burst;
    uint32_t dest_burst;

    if(!dma_dev || !vchan || !sgl || sg_len == 0) {
        // 取不到设备信息、取不到虚拟通道、链表不存在或者len是0，就是无效请求，直接返回NULL
        return NULL;
    }

    // 在这里检查通道参数是否有效
    switch (vchan->cfg.src_addr_width) {                        // 源设备位宽（根据DMA_CFG_REG_t 结构体的DMA_SRC_DATA_WIDTH 项要求）
        case DMA_SLAVE_BUSWIDTH_1_BYTE: {
            src_width = 0;  // 1字节就是8位
            break;
        }
        case DMA_SLAVE_BUSWIDTH_2_BYTES: {
            src_width = 1;  // 2字节就是16位
            break;
        }
        case DMA_SLAVE_BUSWIDTH_4_BYTES: {
            src_width = 2;   // 4字节就是32位
            break;
        }
        case DMA_SLAVE_BUSWIDTH_8_BYTES: {
            src_width = 3;   // 8字节就是64位
            break;
        }
        default: {
            // 其他情况无效，直接返回
            return NULL;
        }
    }
    switch (vchan->cfg.dst_addr_width) {                        // 目标设备位宽（根据DMA_CFG_REG_t 结构体的DMA_DEST_DATA_WIDTH 项要求）
        case DMA_SLAVE_BUSWIDTH_1_BYTE: {
            dest_width = 0; // 1字节就是8位
            break;
        }
        case DMA_SLAVE_BUSWIDTH_2_BYTES: {
            dest_width = 1; // 2字节就是16位
            break;
        }
        case DMA_SLAVE_BUSWIDTH_4_BYTES: {
            dest_width = 2;  // 4字节就是32位
            break;
        }
        case DMA_SLAVE_BUSWIDTH_8_BYTES: {
            dest_width = 3;  // 8字节就是64位
            break;
        }
        default: {
            // 其他情况无效，直接返回
            return NULL;
        }
    }
    switch (vchan->cfg.src_maxburst) {                          // 源设备突发长度（根据DMA_CFG_REG_t 结构体的DMA_SRC_BST_LEN 项要求）
        case 1: {
            src_burst = 0;
            break;
        }
        case 4: {
            src_burst = 1;
            break;
        }
        case 8: {
            src_burst = 2;
            break;
        }
        case 16: {
            src_burst = 3;
            break;
        }
        default: {
            // 其他情况无效，直接返回
            return NULL;
        }
    }
    switch (vchan->cfg.dst_maxburst) {                          // 目标设备突发长度（根据DMA_CFG_REG_t 结构体的DMA_DEST_BST_LEN 项要求）
        case 1: {
            dest_burst = 0;
            break;
        }
        case 4: {
            dest_burst = 1;
            break;
        }
        case 8: {
            dest_burst = 2;
            break;
        }
        case 16: {
            dest_burst = 3;
            break;
        }
        default: {
            // 其他情况无效，直接返回
            return NULL;
        }
    }

    // 让内核分配软件描述符内存并初始化清空
    taskDesc = kzalloc(sizeof(*taskDesc), GFP_NOWAIT);
    if(!taskDesc) {
        // 这个不用说，失败返回
        return NULL;
    }
    memset(taskDesc, 0, sizeof(*taskDesc));

    // 通过scatterlist提供的的遍历宏来遍历所有链表（最好专车专用，其实自己钻到底层写while循环也行）
    for_each_sg(sgl, sg_node, sg_len, i) {
        // 对于每个结点，就创建一个描述符
        hardwareDesc = dma_pool_alloc(dma_dev->pool, GFP_NOWAIT, &physical_addr);
        if (!hardwareDesc) {
            dev_err(dma_dev->slave.dev, "Failed to alloc DMA_HardWare_Descriptor memory\n");
            // 失败了就把所有硬件描述符的内存释放了

            // 第一个描述符记录在taskDesc中
            physical_addr = taskDesc->physical_addr;
            hardwareDesc = taskDesc->virtual_addr;
            temp_hardwareDesc = hardwareDesc;

            while(temp_hardwareDesc) {
                dma_pool_free(dma_dev->pool, hardwareDesc, physical_addr);
                physical_addr = temp_hardwareDesc->p_next_dma_descriptor;
                hardwareDesc = temp_hardwareDesc->v_next_dma_descriptor;
                // 链表结点步进
                temp_hardwareDesc = hardwareDesc;
            }
            // 再释放任务描述符
            kfree(taskDesc);
            // 返回NULL
            return NULL;
        }
        memset(hardwareDesc, 0, sizeof(*hardwareDesc));

        // 把软件描述符中的结点信息补上，这是第一个结点
        if(taskDesc->virtual_addr == NULL) {
            taskDesc->physical_addr = physical_addr;
            taskDesc->virtual_addr = hardwareDesc;
        }

        if(tail) {
            // 不是第一个结点，需要串到链表末尾
            tail->p_next_dma_descriptor = physical_addr;
            tail->v_next_dma_descriptor = hardwareDesc;
        }
        // 以下是无论如何都要做的

        tail = hardwareDesc;    // 更新尾结点
        hardwareDesc->p_next_dma_descriptor = DMA_DESCRIPTOR_END_ADDRESS;   // 新的尾结点当然没有下一个任务了
        hardwareDesc->v_next_dma_descriptor = NULL; // 同上

        // 根据方向配置硬件描述符各项参数（注意要通过宏提取sg链表结点里面的信息，这是比较推荐的做法，否则需要自己区分各种情况，很麻烦）

        switch (dir) {
            case DMA_MEM_TO_DEV: {
                // 源地址是 scatterlist 中的地址，目标地址是设备的地址
                hardwareDesc->src.DMA_CUR_SRC_ADDR = sg_dma_address(sg_node);
                hardwareDesc->len = sg_dma_len(sg_node);

                hardwareDesc->para.WAIT_CYC = 8;            // 说明一下，按照参考驱动的源代码，普通等待时间被设置为8，这边有8位，范围就是 0 到 0xff = 255，不敢改，那就还是8吧

                // 从 dma_slave_config 结构体中提取信息
                hardwareDesc->dst.DMA_CUR_DEST_ADDR = vchan->cfg.dst_addr;  // 目标地址


                hardwareDesc->cfg.DMA_SRC_DRQ_TYPE = 1;                 // 内存到设备，源设备肯定是内存，根据DRQ表，当然是1
                hardwareDesc->cfg.DMA_DEST_DRQ_TYPE = vchan->port;      // 具体看hc_dma_of_xlate写入的是什么

                hardwareDesc->cfg.DMA_SRC_ADDR_MODE = 0;    // 源设备内存当然是线性模式，这不用解释
                hardwareDesc->cfg.DMA_DEST_ADDR_MODE = 1;   // 目标设备不知道是什么，一律当作IO模式处理

                break;
            }
            case DMA_DEV_TO_MEM: {
                // 源地址是设备的地址，目标地址是 scatterlist 中的地址
                hardwareDesc->dst.DMA_CUR_DEST_ADDR = sg_dma_address(sg_node);
                hardwareDesc->len = sg_dma_len(sg_node);

                // 从 dma_slave_config 结构体中提取信息
                hardwareDesc->src.DMA_CUR_SRC_ADDR = vchan->cfg.src_addr;   // 目标地址

                hardwareDesc->para.WAIT_CYC = 8;            // 说明一下，按照参考驱动的源代码，普通等待时间被设置为8，这边有8位，范围就是 0 到 0xff = 255，不敢改，那就还是8吧

                hardwareDesc->cfg.DMA_SRC_DRQ_TYPE = vchan->port;       // 具体看hc_dma_of_xlate写入的是什么
                hardwareDesc->cfg.DMA_DEST_DRQ_TYPE = 1;                // 设备到内存，源设备肯定是内存，根据DRQ表，当然是1

                hardwareDesc->cfg.DMA_SRC_ADDR_MODE = 1;    // 源设备不知道是什么，一律当作IO模式处理
                hardwareDesc->cfg.DMA_DEST_ADDR_MODE = 0;   // 目标设备内存当然是线性模式，这不用解释

                break;
            }
            default: {
                // 目前不支持其他情况，只支持这两个
                // 我一直觉得该有设备到设备，但是原来的参考代码就没支持
                break;
            }
        }

        // 这些是方向无关的参数
        hardwareDesc->cfg.DMA_SRC_DATA_WIDTH = src_width;
        hardwareDesc->cfg.DMA_DEST_DATA_WIDTH = dest_width;
        hardwareDesc->cfg.DMA_SRC_BST_LEN = src_burst;
        hardwareDesc->cfg.DMA_DEST_BST_LEN = dest_burst;

    }

    // 让Linux的DMA驱动框架完成后续配置，这里不管了
    return vchan_tx_prep(&vchan->vc, &taskDesc->vd, flags);
}

```



### 2.3 功能测试

改进测试函数，因为用内存模拟设备，因此只能测试设备到内存，内存到设备我参考的Linux内核的驱动都测不了。

dma_test.c修改如下：

```c
#include <linux/module.h>
#include <linux/dmaengine.h>
#include <linux/dma-mapping.h>
#include <linux/init.h>
#include <linux/interrupt.h>
#include <linux/slab.h>
#include <linux/platform_device.h>
#include <linux/wait.h>
#include <linux/completion.h>
#include <linux/scatterlist.h>
#include <linux/string.h>
#include <linux/io.h>

#define DMA_BUFFER_SIZE 1024

static dma_addr_t dma_src, dma_dst;
static char *src_buf, *dst_buf, *device_mem;  // 模拟设备的内存
static struct dma_chan *dma_chan;
static struct completion dma_complete;

static void dma_callback(void *completion)
{
    complete(completion);
    pr_info("DMA transfer completed\n");
}

static int verify_data(const char *src, const char *dst, size_t size)
{
    if (memcmp(src, dst, size) == 0) {
        pr_info("Data verification successful\n");
        return 0;
    } else {
        pr_err("Data verification failed\n");
        return -1;
    }
}

static int dma_test(enum dma_transfer_direction direction)
{
    struct dma_device *dma_dev;
    struct dma_async_tx_descriptor *tx;
    dma_cap_mask_t mask;
    struct dma_slave_config slave_config;
    struct scatterlist sg;
    enum dma_ctrl_flags flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;
    int ret;
    dma_addr_t device_phys_addr;

    pr_info("DMA test started\n");

    // Step 1: 设置DMA引擎能力掩码
    dma_cap_zero(mask);
    dma_cap_set(DMA_SLAVE, mask);

    // Step 2: 请求DMA通道
    dma_chan = dma_request_chan_by_mask(&mask);
    if (IS_ERR(dma_chan)) {
        pr_err("Failed to request DMA channel\n");
        return PTR_ERR(dma_chan);
    }

    dma_dev = dma_chan->device;

    // Step 3: 分配源和目标缓冲区，以及模拟设备的内存
    src_buf = kzalloc(DMA_BUFFER_SIZE, GFP_KERNEL);
    dst_buf = kzalloc(DMA_BUFFER_SIZE, GFP_KERNEL);
    device_mem = kzalloc(DMA_BUFFER_SIZE, GFP_KERNEL);  // 模拟设备的内存

    if (!src_buf || !dst_buf || !device_mem) {
        pr_err("Failed to allocate buffers\n");
        ret = -ENOMEM;
        goto err_free_buf;
    }

    // 初始化源缓冲区数据
    memset(src_buf, 0xAA, DMA_BUFFER_SIZE);  // 用特定的模式填充源缓冲区
    memset(device_mem, 0, DMA_BUFFER_SIZE);  // 初始化模拟设备内存
    memset(dst_buf, 0, DMA_BUFFER_SIZE);     // 初始化目标缓冲区

    // 获取设备模拟内存的物理地址
    device_phys_addr = virt_to_phys(device_mem);

    // Step 4: 配置 DMA slave 传输
    memset(&slave_config, 0, sizeof(slave_config));
    slave_config.direction = direction;
    slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES; // 根据实际配置
    slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES; // 根据实际配置
    slave_config.src_maxburst = 8; // 合理设置
    slave_config.dst_maxburst = 8; // 合理设置

    pr_info("Configuring DMA: src_maxburst=%d, dst_maxburst=%d, src_addr_width=%d, dst_addr_width=%d\n",
            slave_config.src_maxburst, slave_config.dst_maxburst,
            slave_config.src_addr_width, slave_config.dst_addr_width);

    ret = dmaengine_slave_config(dma_chan, &slave_config);
    if (ret) {
        pr_err("Failed to configure DMA slave\n");
        goto err_free_buf;
    }

    // Step 5: 准备scatter-gather列表
    sg_init_one(&sg, src_buf, DMA_BUFFER_SIZE);

    dma_src = dma_map_single(dma_dev->dev, src_buf, DMA_BUFFER_SIZE, DMA_TO_DEVICE);
    if (dma_mapping_error(dma_dev->dev, dma_src)) {
        pr_err("DMA mapping error\n");
        ret = -EIO;
        goto err_free_buf;
    }

    sg_dma_address(&sg) = dma_src;
    sg_dma_len(&sg) = DMA_BUFFER_SIZE;

    // Step 6: 准备DMA传输
    tx = dmaengine_prep_slave_sg(dma_chan, &sg, 1, direction, flags);
    if (!tx) {
        pr_err("Failed to prepare DMA transfer\n");
        ret = -EIO;
        goto err_free_buf;
    }

    // Step 7: 设置DMA传输完成的回调函数
    init_completion(&dma_complete);
    tx->callback = dma_callback;
    tx->callback_param = &dma_complete;

    // Step 8: 提交并启动DMA传输
    dmaengine_submit(tx);
    dma_async_issue_pending(dma_chan);

    // Step 9: 等待DMA传输完成
    wait_for_completion(&dma_complete);

    pr_info("DMA transfer completed\n");

    // Step 10: 数据传输后的完整性校验
    if (direction == DMA_MEM_TO_DEV) {
        pr_info("Verifying data from memory to device\n");
        ret = verify_data(src_buf, device_mem, DMA_BUFFER_SIZE);  // 校验内存到设备
    } else if (direction == DMA_DEV_TO_MEM) {
        pr_info("Verifying data from device to memory\n");
        ret = verify_data(device_mem, dst_buf, DMA_BUFFER_SIZE);  // 校验设备到内存
    }

err_free_buf:
    dma_unmap_single(dma_dev->dev, dma_src, DMA_BUFFER_SIZE, DMA_TO_DEVICE);
    kfree(src_buf);
    kfree(dst_buf);
    kfree(device_mem);
    dma_release_channel(dma_chan);

    return ret;
}

static int __init dma_test_init(void)
{
    pr_info("Initializing DMA test module\n");

    // 只能测试从模拟设备到内存

    // 测试从设备到内存的DMA传输
    if (dma_test(DMA_DEV_TO_MEM) < 0) {
        pr_err("Device to memory DMA test failed\n");
    }

    return 0;
}

static void __exit dma_test_exit(void)
{
    pr_info("Exiting DMA test module\n");
}

module_init(dma_test_init);
module_exit(dma_test_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("huangcheng");
MODULE_DESCRIPTION("DMA slave test module with data verification and physical address handling");

```

原版驱动（34条通道，我的驱动是30条通道，可以直接看出来区别）的测试结果为：

```bash
/home # ls /sys/class/dma
dma0chan0   dma0chan14  dma0chan2   dma0chan25  dma0chan30  dma0chan6
dma0chan1   dma0chan15  dma0chan20  dma0chan26  dma0chan31  dma0chan7
dma0chan10  dma0chan16  dma0chan21  dma0chan27  dma0chan32  dma0chan8
dma0chan11  dma0chan17  dma0chan22  dma0chan28  dma0chan33  dma0chan9
dma0chan12  dma0chan18  dma0chan23  dma0chan29  dma0chan4
dma0chan13  dma0chan19  dma0chan24  dma0chan3   dma0chan5
/home # insmod dma_test.ko
[  126.466327] dma_test: loading out-of-tree module taints kernel.
[  126.472842] Initializing DMA test module
[  126.476780] DMA test started
[  126.479731] Configuring DMA: src_maxburst=8, dst_maxburst=8, src_addr_width=4, dst_addr_width=4
[  126.488554] DMA transfer completed
[  126.492016] DMA transfer completed
[  126.495427] Verifying data from device to memory
[  126.500073] Data verification successful

```

本项目编写的DMA驱动（可以看出明显的DMA通道从没有到有，而且是明确的30条）：

```bash
/home # ls /sys/class/dma
/home # insmod hc_opi_one_dma.ko
[   61.764194] hc_opi_one_dma: loading out-of-tree module taints kernel.
/home # ls /sys/class/dma
dma0chan0   dma0chan13  dma0chan18  dma0chan22  dma0chan27  dma0chan5
dma0chan1   dma0chan14  dma0chan19  dma0chan23  dma0chan28  dma0chan6
dma0chan10  dma0chan15  dma0chan2   dma0chan24  dma0chan29  dma0chan7
dma0chan11  dma0chan16  dma0chan20  dma0chan25  dma0chan3   dma0chan8
dma0chan12  dma0chan17  dma0chan21  dma0chan26  dma0chan4   dma0chan9
/home # insmod dma_test.ko
[   75.301011] Initializing DMA test module
[   75.304966] DMA test started
[   75.307866] Configuring DMA: src_maxburst=8, dst_maxburst=8, src_addr_width=4, dst_addr_width=4
[   75.316780] DMA transfer completed
[   75.320258] DMA transfer completed
[   75.323668] Verifying data from device to memory
[   75.328297] Data verification successful

```



## 3. 实现循环DMA

### 3.1 实现过程

循环DMA实际上就是在实现从设备和内存之间的传输的时候的一种特殊情况，简单来说就是把DMA描述符链表回环了，不用 `scatterlist` 而是自己计算地址，最终把形成的DMA描述符链表回环，形成无穷无尽的循环。

```c
static struct dma_async_tx_descriptor *hc_dma_prep_dma_cyclic(
        struct dma_chan *chan, dma_addr_t buf_addr, size_t buf_len, size_t period_len,
        enum dma_transfer_direction dir, unsigned long flags) {

    // 循环DMA其实类似于连续的hc_dma_prep_slave_sg
    // 它的地址是连续计算出来的

    // 获取所需的两个指针，设备信息结构体和虚拟通道结构体
    DMA_DEV_Info *dma_dev = (DMA_DEV_Info *)(chan->device);
    DMA_Virtual_Channel_Info *vchan = (DMA_Virtual_Channel_Info *)chan;

    // 两种DMA描述符

    DMA_TASK_Descriptor *taskDesc;          // 软件（驱动程序）用的描述符
    DMA_HardWare_Descriptor *hardwareDesc;  // 硬件用的描述符

    DMA_HardWare_Descriptor *tail = NULL;   // 为了串到链表尾结点用到

    DMA_HardWare_Descriptor *temp_hardwareDesc; // 销毁描述符的时候用到的变量

    // 描述符物理地址
    dma_addr_t physical_addr;

    // 计数器
    uint32_t i;

    // 计算总共要多少次（它是发定长数据，直到发完为止）
    uint32_t count = buf_len / period_len;

    // 通道参数，每个描述符都用得到
    uint32_t src_width;
    uint32_t dest_width;
    uint32_t src_burst;
    uint32_t dest_burst;

    if(!dma_dev || !vchan || buf_addr == 0 || buf_len == 0 || period_len == 0) {
        // 取不到设备信息、取不到虚拟通道、链表不存在或者len是0，就是无效请求，直接返回NULL
        return NULL;
    }

    // 在这里检查通道参数是否有效
    switch (vchan->cfg.src_addr_width) {                        // 源设备位宽（根据DMA_CFG_REG_t 结构体的DMA_SRC_DATA_WIDTH 项要求）
        case DMA_SLAVE_BUSWIDTH_1_BYTE: {
            src_width = 0;  // 1字节就是8位
            break;
        }
        case DMA_SLAVE_BUSWIDTH_2_BYTES: {
            src_width = 1;  // 2字节就是16位
            break;
        }
        case DMA_SLAVE_BUSWIDTH_4_BYTES: {
            src_width = 2;   // 4字节就是32位
            break;
        }
        case DMA_SLAVE_BUSWIDTH_8_BYTES: {
            src_width = 3;   // 8字节就是64位
            break;
        }
        default: {
            // 其他情况无效，直接返回
            return NULL;
        }
    }
    switch (vchan->cfg.dst_addr_width) {                        // 目标设备位宽（根据DMA_CFG_REG_t 结构体的DMA_DEST_DATA_WIDTH 项要求）
        case DMA_SLAVE_BUSWIDTH_1_BYTE: {
            dest_width = 0; // 1字节就是8位
            break;
        }
        case DMA_SLAVE_BUSWIDTH_2_BYTES: {
            dest_width = 1; // 2字节就是16位
            break;
        }
        case DMA_SLAVE_BUSWIDTH_4_BYTES: {
            dest_width = 2;  // 4字节就是32位
            break;
        }
        case DMA_SLAVE_BUSWIDTH_8_BYTES: {
            dest_width = 3;  // 8字节就是64位
            break;
        }
        default: {
            // 其他情况无效，直接返回
            return NULL;
        }
    }
    switch (vchan->cfg.src_maxburst) {                          // 源设备突发长度（根据DMA_CFG_REG_t 结构体的DMA_SRC_BST_LEN 项要求）
        case 1: {
            src_burst = 0;
            break;
        }
        case 4: {
            src_burst = 1;
            break;
        }
        case 8: {
            src_burst = 2;
            break;
        }
        case 16: {
            src_burst = 3;
            break;
        }
        default: {
            // 其他情况无效，直接返回
            return NULL;
        }
    }
    switch (vchan->cfg.dst_maxburst) {                          // 目标设备突发长度（根据DMA_CFG_REG_t 结构体的DMA_DEST_BST_LEN 项要求）
        case 1: {
            dest_burst = 0;
            break;
        }
        case 4: {
            dest_burst = 1;
            break;
        }
        case 8: {
            dest_burst = 2;
            break;
        }
        case 16: {
            dest_burst = 3;
            break;
        }
        default: {
            // 其他情况无效，直接返回
            return NULL;
        }
    }

    // 让内核分配软件描述符内存并初始化清空
    taskDesc = kzalloc(sizeof(*taskDesc), GFP_NOWAIT);
    if(!taskDesc) {
        // 这个不用说，失败返回
        return NULL;
    }
    memset(taskDesc, 0, sizeof(*taskDesc));

    for(i = 0; i < count; i++) {
        // 对于每个结点，就创建一个描述符
        hardwareDesc = dma_pool_alloc(dma_dev->pool, GFP_NOWAIT, &physical_addr);
        if (!hardwareDesc) {
            dev_err(dma_dev->slave.dev, "Failed to alloc DMA_HardWare_Descriptor memory\n");
            // 失败了就把所有硬件描述符的内存释放了

            // 第一个描述符记录在taskDesc中
            physical_addr = taskDesc->physical_addr;
            hardwareDesc = taskDesc->virtual_addr;
            temp_hardwareDesc = hardwareDesc;

            while(temp_hardwareDesc) {
                dma_pool_free(dma_dev->pool, hardwareDesc, physical_addr);
                physical_addr = temp_hardwareDesc->p_next_dma_descriptor;
                hardwareDesc = temp_hardwareDesc->v_next_dma_descriptor;
                // 链表结点步进
                temp_hardwareDesc = hardwareDesc;
            }
            // 再释放任务描述符
            kfree(taskDesc);
            // 返回NULL
            return NULL;
        }
        memset(hardwareDesc, 0, sizeof(*hardwareDesc));

        // 把软件描述符中的结点信息补上，这是第一个结点
        if(taskDesc->virtual_addr == NULL) {
            taskDesc->physical_addr = physical_addr;
            taskDesc->virtual_addr = hardwareDesc;
        }

        if(tail) {
            // 不是第一个结点，需要串到链表末尾
            tail->p_next_dma_descriptor = physical_addr;
            tail->v_next_dma_descriptor = hardwareDesc;
        }
        // 以下是无论如何都要做的

        tail = hardwareDesc;    // 更新尾结点
        hardwareDesc->p_next_dma_descriptor = DMA_DESCRIPTOR_END_ADDRESS;   // 新的尾结点当然没有下一个任务了
        hardwareDesc->v_next_dma_descriptor = NULL; // 同上

        // 根据方向配置硬件描述符各项参数

        switch (dir) {
            case DMA_MEM_TO_DEV: {
                // 源地址是buf_addr + offset，目标地址是设备的地址
                hardwareDesc->src.DMA_CUR_SRC_ADDR = buf_addr + i * period_len;
                hardwareDesc->len = period_len;

                hardwareDesc->para.WAIT_CYC = 8;            // 说明一下，按照参考驱动的源代码，普通等待时间被设置为8，这边有8位，范围就是 0 到 0xff = 255，不敢改，那就还是8吧

                // 从 dma_slave_config 结构体中提取信息
                hardwareDesc->dst.DMA_CUR_DEST_ADDR = vchan->cfg.dst_addr;  // 目标地址


                hardwareDesc->cfg.DMA_SRC_DRQ_TYPE = 1;                 // 内存到设备，源设备肯定是内存，根据DRQ表，当然是1
                hardwareDesc->cfg.DMA_DEST_DRQ_TYPE = vchan->port;      // 具体看hc_dma_of_xlate写入的是什么

                hardwareDesc->cfg.DMA_SRC_ADDR_MODE = 0;    // 源设备内存当然是线性模式，这不用解释
                hardwareDesc->cfg.DMA_DEST_ADDR_MODE = 1;   // 目标设备不知道是什么，一律当作IO模式处理

                break;
            }
            case DMA_DEV_TO_MEM: {
                // 源地址是设备的地址，目标地址是 buf_addr + offset
                hardwareDesc->dst.DMA_CUR_DEST_ADDR = buf_addr + i * period_len;
                hardwareDesc->len = period_len;

                // 从 dma_slave_config 结构体中提取信息
                hardwareDesc->src.DMA_CUR_SRC_ADDR = vchan->cfg.src_addr;   // 目标地址

                hardwareDesc->para.WAIT_CYC = 8;            // 说明一下，按照参考驱动的源代码，普通等待时间被设置为8，这边有8位，范围就是 0 到 0xff = 255，不敢改，那就还是8吧

                hardwareDesc->cfg.DMA_SRC_DRQ_TYPE = vchan->port;       // 具体看hc_dma_of_xlate写入的是什么
                hardwareDesc->cfg.DMA_DEST_DRQ_TYPE = 1;                // 设备到内存，源设备肯定是内存，根据DRQ表，当然是1

                hardwareDesc->cfg.DMA_SRC_ADDR_MODE = 1;    // 源设备不知道是什么，一律当作IO模式处理
                hardwareDesc->cfg.DMA_DEST_ADDR_MODE = 0;   // 目标设备内存当然是线性模式，这不用解释

                break;
            }
            default: {
                // 目前不支持其他情况，只支持这两个
                // 我一直觉得该有设备到设备，但是原来的参考代码就没支持
                break;
            }
        }

        // 这些是方向无关的参数
        hardwareDesc->cfg.DMA_SRC_DATA_WIDTH = src_width;
        hardwareDesc->cfg.DMA_DEST_DATA_WIDTH = dest_width;
        hardwareDesc->cfg.DMA_SRC_BST_LEN = src_burst;
        hardwareDesc->cfg.DMA_DEST_BST_LEN = dest_burst;
    }

    // 这里是循环DMA的特殊处理

    // 把DMA描述符链表直接回环
    tail->p_next_dma_descriptor = taskDesc->physical_addr;
    // 不要回环驱动用的 v_next_dma_descriptor，那样删除链表的时候只会引起不必要的麻烦

    // 通道的循环属性打上
    vchan->cyclic = true;

    // 让Linux的DMA驱动框架完成后续配置，这里不管了
    return vchan_tx_prep(&vchan->vc, &taskDesc->vd, flags);
}

```



### 3.2 功能测试

测试模块dma_test.ko

```c
#include <linux/module.h>
#include <linux/dmaengine.h>
#include <linux/dma-mapping.h>
#include <linux/init.h>
#include <linux/interrupt.h>
#include <linux/slab.h>
#include <linux/platform_device.h>
#include <linux/wait.h>
#include <linux/completion.h>
#include <linux/scatterlist.h>
#include <linux/string.h>
#include <linux/io.h>

#define DMA_BUFFER_SIZE 1024

static dma_addr_t dma_src, dma_dst;
static char *src_buf, *dst_buf, *device_mem;  // 模拟设备的内存
static struct dma_chan *dma_chan;
static struct completion dma_complete;

static void dma_callback(void *completion)
{
    complete(completion);
    pr_info("DMA transfer completed\n");
}

static int verify_data(const char *src, const char *dst, size_t size)
{
    if (memcmp(src, dst, size) == 0) {
        pr_info("Data verification successful\n");
        return 0;
    } else {
        pr_err("Data verification failed\n");
        return -1;
    }
}

static int dma_test(enum dma_transfer_direction direction)
{
    struct dma_device *dma_dev;
    struct dma_async_tx_descriptor *tx;
    dma_cap_mask_t mask;
    struct dma_slave_config slave_config;
    enum dma_ctrl_flags flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;
    int ret;
    dma_addr_t device_phys_addr;

    pr_info("Cyclic DMA test started\n");

    // Step 1: 设置DMA引擎能力掩码
    dma_cap_zero(mask);
    dma_cap_set(DMA_SLAVE, mask);

    // Step 2: 请求DMA通道
    dma_chan = dma_request_chan_by_mask(&mask);
    if (IS_ERR(dma_chan)) {
        pr_err("Failed to request DMA channel\n");
        return PTR_ERR(dma_chan);
    }

    dma_dev = dma_chan->device;

    // Step 3: 分配源和目标缓冲区，以及模拟设备的内存
    src_buf = kzalloc(DMA_BUFFER_SIZE, GFP_KERNEL);
    dst_buf = kzalloc(DMA_BUFFER_SIZE, GFP_KERNEL);
    device_mem = kzalloc(DMA_BUFFER_SIZE, GFP_KERNEL);  // 模拟设备的内存

    if (!src_buf || !dst_buf || !device_mem) {
        pr_err("Failed to allocate buffers\n");
        ret = -ENOMEM;
        goto err_free_buf;
    }

    // 初始化源缓冲区数据
    memset(src_buf, 0xAA, DMA_BUFFER_SIZE);  // 用特定的模式填充源缓冲区
    memset(device_mem, 0, DMA_BUFFER_SIZE);  // 初始化模拟设备内存
    memset(dst_buf, 0, DMA_BUFFER_SIZE);     // 初始化目标缓冲区

    // 获取设备模拟内存的物理地址
    device_phys_addr = virt_to_phys(device_mem);

    // Step 4: 配置 DMA slave 传输
    memset(&slave_config, 0, sizeof(slave_config));
    slave_config.direction = direction;
    slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES; // 根据实际配置
    slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES; // 根据实际配置
    slave_config.src_maxburst = 8; // 合理设置
    slave_config.dst_maxburst = 8; // 合理设置

    pr_info("Configuring DMA: src_maxburst=%d, dst_maxburst=%d, src_addr_width=%d, dst_addr_width=%d\n",
            slave_config.src_maxburst, slave_config.dst_maxburst,
            slave_config.src_addr_width, slave_config.dst_addr_width);

    ret = dmaengine_slave_config(dma_chan, &slave_config);
    if (ret) {
        pr_err("Failed to configure DMA slave\n");
        goto err_free_buf;
    }

    // Step 5: 设置DMA循环传输
    dma_src = dma_map_single(dma_dev->dev, src_buf, DMA_BUFFER_SIZE, DMA_TO_DEVICE);
    if (dma_mapping_error(dma_dev->dev, dma_src)) {
        pr_err("DMA mapping error\n");
        ret = -EIO;
        goto err_free_buf;
    }

    // Step 6: 准备循环DMA传输
    tx = dmaengine_prep_dma_cyclic(dma_chan, dma_src, DMA_BUFFER_SIZE, DMA_BUFFER_SIZE / 2, direction, flags);
    if (!tx) {
        pr_err("Failed to prepare cyclic DMA transfer\n");
        ret = -EIO;
        goto err_free_buf;
    }

    // Step 7: 设置DMA传输完成的回调函数
    init_completion(&dma_complete);
    tx->callback = dma_callback;
    tx->callback_param = &dma_complete;

    // Step 8: 提交并启动DMA传输
    dmaengine_submit(tx);
    dma_async_issue_pending(dma_chan);

    // Step 9: 等待DMA传输完成
    wait_for_completion(&dma_complete);

    pr_info("Cyclic DMA transfer completed\n");

    // Step 10: 数据传输后的完整性校验
    if (direction == DMA_MEM_TO_DEV) {
        pr_info("Verifying data from memory to device\n");
        ret = verify_data(src_buf, device_mem, DMA_BUFFER_SIZE);  // 校验内存到设备
    } else if (direction == DMA_DEV_TO_MEM) {
        pr_info("Verifying data from device to memory\n");
        ret = verify_data(device_mem, dst_buf, DMA_BUFFER_SIZE);  // 校验设备到内存
    }

err_free_buf:
    dma_unmap_single(dma_dev->dev, dma_src, DMA_BUFFER_SIZE, DMA_TO_DEVICE);
    kfree(src_buf);
    kfree(dst_buf);
    kfree(device_mem);
    dma_release_channel(dma_chan);

    return ret;
}

static int __init dma_test_init(void)
{
    pr_info("Initializing Cyclic DMA test module\n");

    // 只能测试从模拟设备到内存

    // 测试从设备到内存的循环DMA传输
    if (dma_test(DMA_DEV_TO_MEM) < 0) {
        pr_err("Device to memory Cyclic DMA test failed\n");
    }

    return 0;
}

static void __exit dma_test_exit(void)
{
    pr_info("Exiting Cyclic DMA test module\n");
}

module_init(dma_test_init);
module_exit(dma_test_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("huangcheng");
MODULE_DESCRIPTION("Cyclic DMA test module with data verification and physical address handling");

```

原版驱动（34条通道，我的驱动是30条通道，可以直接看出来区别）的测试结果为（循环DMA突出一个循环，无穷无尽，会一直打completed）：

```bash
/home # ls /sys/class/dma
dma0chan0   dma0chan14  dma0chan2   dma0chan25  dma0chan30  dma0chan6
dma0chan1   dma0chan15  dma0chan20  dma0chan26  dma0chan31  dma0chan7
dma0chan10  dma0chan16  dma0chan21  dma0chan27  dma0chan32  dma0chan8
dma0chan11  dma0chan17  dma0chan22  dma0chan28  dma0chan33  dma0chan9
dma0chan12  dma0chan18  dma0chan23  dma0chan29  dma0chan4
dma0chan13  dma0chan19  dma0chan24  dma0chan3   dma0chan5
/home # insmod dma_test.ko
[   48.546733] dma_test: loading out-of-tree module taints kernel.
[   48.553257] Initializing Cyclic DMA test module
[   48.557802] Cyclic DMA test started
[   48.561359] Configuring DMA: src_maxburst=8, dst_maxburst=8, src_addr_width=4, dst_addr_width=4
[   48.570256] DMA transfer completed
[   48.573697] DMA transfer completed
[   48.577119] DMA transfer completed
[   48.580565] DMA transfer completed
[   48.584001] DMA transfer completed
[   48.587447] DMA transfer completed
[   48.590894] Cyclic DMA transfer completed
[   48.594916] Verifying data from device to memory
[   48.599574] Data verification successful
[   48.603552] DMA transfer completed
[   48.606974] DMA transfer completed
[   48.610414] DMA transfer completed
[   48.613871] DMA transfer completed
[   48.617294] DMA transfer completed
/home # [   48.622033] DMA transfer completed
[   48.626085] DMA transfer completed
[   48.629575] DMA transfer completed
[   48.633001] DMA transfer completed
[   48.636420] DMA transfer completed
[   48.639855] DMA transfer completed
[   48.643348] DMA transfer completed
[   48.646775] DMA transfer completed

```

本项目编写的DMA驱动（可以看出明显的DMA通道从没有到有，而且是明确的30条）：

```bash
/home # ls /sys/class/dma
/home # insmod hc_opi_one_dma.ko
[   30.847418] hc_opi_one_dma: loading out-of-tree module taints kernel.
/home # ls /sys/class/dma
dma0chan0   dma0chan13  dma0chan18  dma0chan22  dma0chan27  dma0chan5
dma0chan1   dma0chan14  dma0chan19  dma0chan23  dma0chan28  dma0chan6
dma0chan10  dma0chan15  dma0chan2   dma0chan24  dma0chan29  dma0chan7
dma0chan11  dma0chan16  dma0chan20  dma0chan25  dma0chan3   dma0chan8
dma0chan12  dma0chan17  dma0chan21  dma0chan26  dma0chan4   dma0chan9
/home # insmod dma_test.ko
[   45.064258] Initializing Cyclic DMA test module
[   45.068819] Cyclic DMA test started
[   45.072414] Configuring DMA: src_maxburst=8, dst_maxburst=8, src_addr_width=4, dst_addr_width=4
[   45.081278] DMA transfer completed
[   45.084722] DMA transfer completed
[   45.088148] DMA transfer completed
[   45.091589] DMA transfer completed
[   45.095068] DMA transfer completed
[   45.098489] DMA transfer completed
[   45.101933] Cyclic DMA transfer completed
[   45.105957] Verifying data from device to memory
[   45.110616] Data verification successful
[   45.114602] DMA transfer completed
[   45.118059] DMA transfer completed
[   45.121501] DMA transfer completed
[   45.124954] DMA transfer completed
[   45.128375] DMA transfer completed
/home # [   45.133229] DMA transfer completed
[   45.137251] DMA transfer completed
[   45.140803] DMA transfer completed
[   45.144229] DMA transfer completed
[   45.147648] DMA transfer completed
[   45.151087] DMA transfer completed

```

